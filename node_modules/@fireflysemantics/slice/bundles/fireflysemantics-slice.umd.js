(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('rxjs'), require('rxjs/operators'), require('nanoid')) :
  typeof define === 'function' && define.amd ? define('@fireflysemantics/slice', ['exports', 'rxjs', 'rxjs/operators', 'nanoid'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.fireflysemantics = global.fireflysemantics || {}, global.fireflysemantics.slice = {}), global.rxjs, global.rxjs.operators, global.nanoid));
}(this, (function (exports, rxjs, operators, nanoid) { 'use strict';

  ;

  /**
   * Abstract Entity base class with the
   * gid and id properties declared.
   */
  var Entity = /** @class */ (function () {
      function Entity() {
      }
      return Entity;
  }());

  var SCROLL_UP_DEBOUNCE_TIME_20 = 20;
  var SEARCH_DEBOUNCE_TIME_300 = 300;

  var freeze = Object.freeze;
  var ESTORE_DEFAULT_ID_KEY = "id";
  var ESTORE_DEFAULT_GID_KEY = "gid";
  var ESTORE_CONFIG_DEFAULT = freeze({
      idKey: ESTORE_DEFAULT_ID_KEY,
      guidKey: ESTORE_DEFAULT_GID_KEY
  });
  var AbstractStore = /** @class */ (function () {
      function AbstractStore(config) {
          /**
           * Notifies observers of the store query.
           */
          this.notifyQuery = new rxjs.ReplaySubject(1);
          /**
           * The current query state.
           */
          this._query = '';
          /**
           * Primary index for the stores elements.
           */
          this.entries = new Map();
          /**
           * The element entries that are keyed by
           * an id generated on the server.
           */
          this.idEntries = new Map();
          /**
           * Create notifications that broacast
           * the entire set of entries.
           */
          this.notify = new rxjs.ReplaySubject(1);
          /**
           * Create notifications that broacast
           * store or slice delta state changes.
           */
          this.notifyDelta = new rxjs.ReplaySubject(1);
          this.config = config
              ? freeze(Object.assign(Object.assign({}, ESTORE_CONFIG_DEFAULT), config))
              : ESTORE_CONFIG_DEFAULT;
      }
      Object.defineProperty(AbstractStore.prototype, "query", {
          /**
           * @return A snapshot of the query state.
           */
          get: function () {
              return this._query;
          },
          /**
           * Sets the current query state and notifies observers.
           */
          set: function (query) {
              this._query = query;
              this.notifyQuery.next(this._query);
          },
          enumerable: false,
          configurable: true
      });
      /**
       * Observe the query.
       * @example
         <pre>
        let query$ = source.observeQuery();
        </pre>
      */
      AbstractStore.prototype.observeQuery = function () {
          return this.notifyQuery.asObservable();
      };
      Object.defineProperty(AbstractStore.prototype, "ID_KEY", {
          /**
           * The current id key for the EStore instance.
           * @return this.config.idKey;
           */
          get: function () {
              return this.config.idKey;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(AbstractStore.prototype, "GUID_KEY", {
          /**
           * The current guid key for the EStore instance.
           * @return this.config.guidKey;
           */
          get: function () {
              return this.config.guidKey;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * Call all the notifiers at once.
       *
       * @param v
       * @param delta
       */
      AbstractStore.prototype.notifyAll = function (v, delta) {
          this.notify.next(v);
          this.notifyDelta.next(delta);
      };
      /**
       * Observe store state changes.
       * @param sort Optional sorting function yielding a sorted observable.
       * @example
    ```
    let todos$ = source.observe();
    //or with a sort by title function
    let todos$ = source.observe((a, b)=>(a.title > b.title ? -1 : 1));
    ```
      */
      AbstractStore.prototype.observe = function (sort) {
          if (sort) {
              return this.notify.pipe(operators.map(function (e) { return e.sort(sort); }));
          }
          return this.notify.asObservable();
      };
      /**
       * Observe delta updates.
       * @example
         <pre>
         let todos$ = source.observeDelta();
         </pre>
       */
      AbstractStore.prototype.observeDelta = function () {
          return this.notifyDelta.asObservable();
      };
      /**
       * Check whether the store is empty.
       *
       * @return A hot {@link Observable} that indicates whether the store is empty.
       *
       * @example
        <pre>
        source.isEmpty();
        </pre>
      */
      AbstractStore.prototype.isEmpty = function () {
          return this.notify.pipe(operators.map(function (entries) { return entries.length == 0; }));
      };
      /**
       * Check whether the store is empty.
       *
       * @return A snapshot that indicates whether the store is empty.
       *
       * @example
         <pre>
        source.isEmpty();
        </pre>
      */
      AbstractStore.prototype.isEmptySnapshot = function () {
          return Array.from(this.entries.values()).length == 0;
      };
      /**
       * Returns the number of entries contained.
       * @param p The predicate to apply in order to filter the count
       */
      AbstractStore.prototype.count = function (p) {
          if (p) {
              return this.notify.pipe(operators.map(function (e) { return e.reduce(function (total, e) { return total + (p(e) ? 1 : 0); }, 0); }));
          }
          return this.notify.pipe(operators.map(function (entries) { return entries.length; }));
      };
      /**
       * Returns a snapshot of the number of entries contained in the store.
       * @param p The predicate to apply in order to filter the count
       */
      AbstractStore.prototype.countSnapshot = function (p) {
          if (p) {
              return Array.from(this.entries.values()).filter(p).length;
          }
          return Array.from(this.entries.values()).length;
      };
      /**
       * Snapshot of all entries.
       *
       * @return Snapshot array of all the elements the entities the store contains.
       *
       * @example Observe a snapshot of all the entities in the store.
    ```
    let selectedTodos:Todo[] = source.allSnapshot();
    ```
       */
      AbstractStore.prototype.allSnapshot = function () {
          return Array.from(this.entries.values());
      };
      /**
       * Returns true if the entries contain the identified instance.
       *
       * @param target Either an instance of type `E` or a `guid` identifying the instance.
       * @param byId Whether the lookup should be performed with the `id` key rather than the `guid`.
       * @returns true if the instance identified by the guid exists, false otherwise.
       *
       * @example
         <pre>
         let contains:boolean = source.contains(guid);
         </pre>
       */
      AbstractStore.prototype.contains = function (target) {
          if (typeof target === "string") {
              return this.entries.get(target) ? true : false;
          }
          var guid = target[this.config.guidKey];
          return this.entries.get(guid) ? true : false;
      };
      /**
       * Returns true if the entries contain the identified instance.
       *
       * @param target Either an instance of type `E` or a `id` identifying the instance.
       * @returns true if the instance identified by the `id` exists, false otherwise.
       *
       * @example
         <pre>
         let contains:boolean = source.contains(guid);
         </pre>
       */
      AbstractStore.prototype.containsById = function (target) {
          if (typeof target === "string") {
              return this.idEntries.get(target) ? true : false;
          }
          var id = target[this.config.idKey];
          return this.idEntries.get(id) ? true : false;
      };
      /**
       * Find and return the entity identified by the GUID parameter
       * if it exists and return it.
       *
       * @param guid
       * @return The entity instance if it exists, null otherwise
       */
      AbstractStore.prototype.findOne = function (guid) {
          return this.entries.get(guid);
      };
      /**
       * Find and return the entity identified by the ID parameter
       * if it exists and return it.
       *
       * @param id
       * @return The entity instance if it exists, null otherwise
       */
      AbstractStore.prototype.findOneByID = function (id) {
          return this.idEntries.get(id);
      };
      /**
       * Snapshot of the entries that match the predicate.
       *
       * @param p The predicate used to query for the selection.
       * @return A snapshot array containing the entities that match the predicate.
       *
       * @example Select all the `Todo` instance where the `title` length is greater than 100.
    ```
    let todos:Todo[]=store.select(todo=>todo.title.length>100);
    ```
       */
      AbstractStore.prototype.select = function (p) {
          var selected = [];
          Array.from(this.entries.values()).forEach(function (e) {
              if (p(e)) {
                  selected.push(e);
              }
          });
          return selected;
      };
      /**
       * Compare entities by GUID
       * @param e1 The first entity
       * @param e2 The second entity
       * @return true if the two entities have equal GUID ids
       * @example Compare `todo1` with `todo2` by `gid`.
    ```
    if (equalsByGUID(todo1, todo2)){...};
    ```
       */
      AbstractStore.prototype.equalsByGUID = function (e1, e2) {
          return e1[this.GUID_KEY] == e2[this.GUID_KEY];
      };
      /**
       * Compare entities by ID
       * @param e1 The first entity
       * @param e2 The second entity
       * @return true if the two entities have equal ID ids
       * @example Compare `todo1` with `todo2` by `id`.
    ```
    if (equalsByID(todo1, todo2)){...};
    ```
       */
      AbstractStore.prototype.equalsByID = function (e1, e2) {
          return e1[this.ID_KEY] == e2[this.ID_KEY];
      };
      /**
       * Calls complete on all {@link BehaviorSubject} instances.
       *
       * Call destroy when disposing of the store.
       */
      AbstractStore.prototype.destroy = function () {
          this.notify.complete();
          this.notifyDelta.complete();
          this.notifyQuery.complete();
      };
      return AbstractStore;
  }());

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  /* global Reflect, Promise */
  var extendStatics = function (d, b) {
      extendStatics = Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
          function (d, b) { for (var p in b)
              if (Object.prototype.hasOwnProperty.call(b, p))
                  d[p] = b[p]; };
      return extendStatics(d, b);
  };
  function __extends(d, b) {
      if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  var __assign = function () {
      __assign = Object.assign || function __assign(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s)
                  if (Object.prototype.hasOwnProperty.call(s, p))
                      t[p] = s[p];
          }
          return t;
      };
      return __assign.apply(this, arguments);
  };
  function __rest(s, e) {
      var t = {};
      for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
              t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
              if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                  t[p[i]] = s[p[i]];
          }
      return t;
  }
  function __decorate(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
      else
          for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                  r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
  }
  function __param(paramIndex, decorator) {
      return function (target, key) { decorator(target, key, paramIndex); };
  }
  function __metadata(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
  }
  function __awaiter(thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try {
              step(generator.next(value));
          }
          catch (e) {
              reject(e);
          } }
          function rejected(value) { try {
              step(generator["throw"](value));
          }
          catch (e) {
              reject(e);
          } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  }
  function __generator(thisArg, body) {
      var _ = { label: 0, sent: function () { if (t[0] & 1)
              throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
      function verb(n) { return function (v) { return step([n, v]); }; }
      function step(op) {
          if (f)
              throw new TypeError("Generator is already executing.");
          while (_)
              try {
                  if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                      return t;
                  if (y = 0, t)
                      op = [op[0] & 2, t.value];
                  switch (op[0]) {
                      case 0:
                      case 1:
                          t = op;
                          break;
                      case 4:
                          _.label++;
                          return { value: op[1], done: false };
                      case 5:
                          _.label++;
                          y = op[1];
                          op = [0];
                          continue;
                      case 7:
                          op = _.ops.pop();
                          _.trys.pop();
                          continue;
                      default:
                          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                              _ = 0;
                              continue;
                          }
                          if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                              _.label = op[1];
                              break;
                          }
                          if (op[0] === 6 && _.label < t[1]) {
                              _.label = t[1];
                              t = op;
                              break;
                          }
                          if (t && _.label < t[2]) {
                              _.label = t[2];
                              _.ops.push(op);
                              break;
                          }
                          if (t[2])
                              _.ops.pop();
                          _.trys.pop();
                          continue;
                  }
                  op = body.call(thisArg, _);
              }
              catch (e) {
                  op = [6, e];
                  y = 0;
              }
              finally {
                  f = t = 0;
              }
          if (op[0] & 5)
              throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
      }
  }
  var __createBinding = Object.create ? (function (o, m, k, k2) {
      if (k2 === undefined)
          k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
  }) : (function (o, m, k, k2) {
      if (k2 === undefined)
          k2 = k;
      o[k2] = m[k];
  });
  function __exportStar(m, o) {
      for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
              __createBinding(o, m, p);
  }
  function __values(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
          return m.call(o);
      if (o && typeof o.length === "number")
          return {
              next: function () {
                  if (o && i >= o.length)
                      o = void 0;
                  return { value: o && o[i++], done: !o };
              }
          };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __read(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
          return o;
      var i = m.call(o), r, ar = [], e;
      try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
              ar.push(r.value);
      }
      catch (error) {
          e = { error: error };
      }
      finally {
          try {
              if (r && !r.done && (m = i["return"]))
                  m.call(i);
          }
          finally {
              if (e)
                  throw e.error;
          }
      }
      return ar;
  }
  /** @deprecated */
  function __spread() {
      for (var ar = [], i = 0; i < arguments.length; i++)
          ar = ar.concat(__read(arguments[i]));
      return ar;
  }
  /** @deprecated */
  function __spreadArrays() {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++)
          s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0; i < il; i++)
          for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
      return r;
  }
  function __spreadArray(to, from, pack) {
      if (pack || arguments.length === 2)
          for (var i = 0, l = from.length, ar; i < l; i++) {
              if (ar || !(i in from)) {
                  if (!ar)
                      ar = Array.prototype.slice.call(from, 0, i);
                  ar[i] = from[i];
              }
          }
      return to.concat(ar || from);
  }
  function __await(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
  }
  function __asyncGenerator(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
      function verb(n) { if (g[n])
          i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
      function resume(n, v) { try {
          step(g[n](v));
      }
      catch (e) {
          settle(q[0][3], e);
      } }
      function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
      function fulfill(value) { resume("next", value); }
      function reject(value) { resume("throw", value); }
      function settle(f, v) { if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]); }
  }
  function __asyncDelegator(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
      function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
  }
  function __asyncValues(o) {
      if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
      function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
      function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
  }
  function __makeTemplateObject(cooked, raw) {
      if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
      }
      else {
          cooked.raw = raw;
      }
      return cooked;
  }
  ;
  var __setModuleDefault = Object.create ? (function (o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function (o, v) {
      o["default"] = v;
  };
  function __importStar(mod) {
      if (mod && mod.__esModule)
          return mod;
      var result = {};
      if (mod != null)
          for (var k in mod)
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                  __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
  }
  function __importDefault(mod) {
      return (mod && mod.__esModule) ? mod : { default: mod };
  }
  function __classPrivateFieldGet(receiver, state, kind, f) {
      if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  }
  function __classPrivateFieldSet(receiver, state, value, kind, f) {
      if (kind === "m")
          throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
  }

  /**
   * Returns all the entities are distinct by the
   * `property` value argument.
   *
   * Note that the implementation uses a `Map<string, E>` to
   * index the entities by key.  Therefore the more recent occurences
   * matching a key instance will overwrite the previous ones.
   *
   * @param property The name of the property to check for distinct values by.
   * @param entities The entities in the array.
   *
   * @example
   ```
    let todos: Todo[] = [
      { id: 1, title: "Lets do it!" },
      { id: 1, title: "Lets do it again!" },
      { id: 2, title: "All done!" }
    ];

    let todos2: Todo[] = [
      { id: 1, title: "Lets do it!" },
      { id: 2, title: "All done!" }
    ];

    expect(distinct(todos, "id").length).toEqual(2);
    expect(distinct(todos2, "id").length).toEqual(2);

   ```
   */
  function distinct(entities, property) {
      var entitiesByProperty = new Map(entities.map(function (e) { return [e[property], e]; }));
      return Array.from(entitiesByProperty.values());
  }
  /**
   * Returns true if all the entities are distinct by the
   * `property` value argument.
   *
   * @param property The name of the property to check for distinct values by.
   * @param entities The entities in the array.
   *
   * @example
   *
   ```
    let todos: Todo[] = [
      { id: 1, title: "Lets do it!" },
      { id: 1, title: "Lets do it again!" },
      { id: 2, title: "All done!" }
    ];

    let todos2: Todo[] = [
      { id: 1, title: "Lets do it!" },
      { id: 2, title: "All done!" }
    ];

    expect(unique(todos, "id")).toBeFalsy();
    expect(unique(todos2, "id")).toBeTruthy();
   ```
   */
  function unique(entities, property) {
      return entities.length == distinct(entities, property).length ? true : false;
  }
  /**
   * Create a global ID
   * @return The global id.
   *
   * @example
   * let e.guid = GUID();
   */
  function GUID() {
      return nanoid.nanoid();
  }
  /**
   * Set the global identfication property on the instance.
   *
   * @param e Entity we want to set the global identifier on.
   * @param gid The name of the `gid` property.  If not specified it defaults to `ESTORE_CONFIG_DEFAULT.guidKey`.
   */
  function attachGUID(e, gid) {
      var guidKey = gid ? gid : ESTORE_CONFIG_DEFAULT.guidKey;
      var id = nanoid.nanoid();
      e[guidKey] = id;
      return id;
  }
  /**
   * Set the global identfication property on the instance.
   *
   * @param e[] Entity array we want to set the global identifiers on.
   * @param gid The name of the `gid` property.  If not specified it defaults to `gid`.
   */
  function attachGUIDs(e, gid) {
      e.forEach(function (e) {
          attachGUID(e, gid);
      });
  }
  /**
   * Create a shallow copy of the argument.
   * @param o The object to copy
   */
  function shallowCopy(o) {
      return Object.assign({}, o);
  }
  /**
   * Create a deep copy of the argument.
   * @param o The object to copy
   */
  function deepCopy(o) {
      return JSON.parse(JSON.stringify(o));
  }
  /**
   * Gets the current active value from the `active`
   * Map.
   *
   * This is used for the scenario where we are managing
   * a single active instance.  For example
   * when selecting a book from a collection of books.
   *
   * The selected `Book` instance becomes the active value.
   *
   * @example
   * const book:Book = getActiveValue(bookStore.active);
   * @param m
   */
  function getActiveValue(m) {
      if (m.size) {
          return m.entries().next().value[1];
      }
      return null;
  }
  /**
   * The method can be used to exclude keys from an instance
   * of type `E`.
   *
   * We can use this to exclude values when searching an object.
   *
   * @param entity An instance of type E
   * @param exclude The keys to exclude
   *
   * @example
   * todo = { id: '1', description: 'Do it!' }
   * let keys = excludeKeys<Todo>(todo, ['id]);
   * // keys = ['description']
   */
  function excludeKeys(entity, exclude) {
      var keys = Object.keys(entity);
      return keys.filter(function (key) {
          return exclude.indexOf(key) < 0;
      });
  }
  /**
   *
   * @param entities The entity to search
   * @param exclude Keys to exclude from each entity
   *
   * @return E[] Array of entities with properties containing the search term.
   */
  function search(query, entities, exclude) {
      if (query === void 0) { query = ''; }
      if (exclude === void 0) { exclude = []; }
      var isArray = Array.isArray;
      query = query.toLowerCase();
      return entities.filter(function (e) {
          //Do the keys calculation on each instance e:E
          //because an instance can have optional parameters,
          //and thus we have to check each instance, not just
          //the first one in the array.
          var keys = excludeKeys(e, exclude);
          return keys.some(function (key) {
              var value = e[key];
              if (!value) {
                  return false;
              }
              if (isArray(value)) {
                  return value.some(function (v) {
                      return String(v).toLowerCase().includes(query);
                  });
              }
              else {
                  return String(value).toLowerCase().includes(query);
              }
          });
      });
  }
  /**
   * @param scrollable The element being scrolled
   * @param debounceMS The number of milliseconds to debounce scroll events
   * @param sp The function returning the scroll position coordinates.
   * @return A boolean valued observable indicating whether the element is scrolling up or down
   */
  function scrollingUp(scrollable, debounceMS, sp) {
      return rxjs.fromEvent(scrollable, 'scroll').pipe(operators.debounceTime(debounceMS), operators.distinctUntilChanged(), operators.map(function (v) { return sp(); }), operators.pairwise(), operators.switchMap(function (p) {
          var y1 = p[0][1];
          var y2 = p[1][1];
          return y1 - y2 > 0 ? rxjs.of(false) : rxjs.of(true);
      }));
  }
  /**
   * Filters the entities properties to the set contained in the
   * `keys` array.
   *
   * @param keys The array of keys that the entity be limited to
   * @param entity The entity to map
   * @return An entity instance that has only the keys provided in the keys array
   */
  function mapEntity(keys, entity) {
      var result = {};
      keys.forEach(function (k) {
          result[k] = entity[k];
      });
      return result;
  }

  var isArray = Array.isArray;
  var Slice = /** @class */ (function (_super) {
      __extends(Slice, _super);
      /**
       * perform initial notification to all observers,
       * such that operations like {@link combineLatest}{}
       * will execute at least once.
       *
       * @param label The slice label
       * @param predicate The slice predicate
       * @param eStore The EStore instance containing the elements considered for slicing
       *
       * @example
         <pre>
         //Empty slice
         new Slice<Todo>(Todo.COMPLETE, todo=>!todo.complete);
    
         //Initialized slice
         let todos = [new Todo(false, "You complete me!"),
                      new Todo(true, "You completed me!")];
         new Slice<Todo>(Todo.COMPLETE, todo=>!todo.complete, todos);
         </pre>
       */
      function Slice(label, predicate, eStore) {
          var _this = _super.call(this) || this;
          _this.label = label;
          _this.predicate = predicate;
          _this.eStore = eStore;
          /* The slice element entries */
          _this.entries = new Map();
          var entities = eStore.allSnapshot();
          _this.config = eStore.config;
          var passed = _this.test(predicate, entities);
          var delta = { type: "Initialize" /* INTIALIZE */, entries: passed };
          _this.post(passed);
          _this.notifyDelta.next(delta);
          return _this;
      }
      /**
       * Add the element if it satisfies the predicate
       * and notify subscribers that an element was added.
       *
       * @param e The element to be considered for slicing
       */
      Slice.prototype.post = function (e) {
          if (isArray(e)) {
              this.postA(e);
          }
          else {
              if (this.predicate(e)) {
                  var id = e[this.config.guidKey];
                  this.entries.set(id, e);
                  var delta = { type: "Post" /* POST */, entries: [e] };
                  this.notifyAll(__spreadArray([], __read(Array.from(this.entries.values()))), delta);
              }
          }
      };
      /**
       * Add the elements if they satisfy the predicate
       * and notify subscribers that elements were added.
       *
       * @param e The element to be considered for slicing
       */
      Slice.prototype.postN = function () {
          var e = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              e[_i] = arguments[_i];
          }
          this.postA(e);
      };
      /**
       * Add the elements if they satisfy the predicate
       * and notify subscribers that elements were added.
       *
       * @param e The element to be considered for slicing
       */
      Slice.prototype.postA = function (e) {
          var _this = this;
          var d = [];
          e.forEach(function (e) {
              if (_this.predicate(e)) {
                  var id = e[_this.config.guidKey];
                  _this.entries.set(id, e);
                  d.push(e);
              }
          });
          var delta = { type: "Post" /* POST */, entries: d };
          this.notifyAll(__spreadArray([], __read(Array.from(this.entries.values()))), delta);
      };
      /**
       * Delete an element from the slice.
       *
       * @param e The element to be deleted if it satisfies the predicate
       */
      Slice.prototype.delete = function (e) {
          if (isArray(e)) {
              this.deleteA(e);
          }
          else {
              if (this.predicate(e)) {
                  var id = e[this.config.guidKey];
                  this.entries.delete(id);
                  var delta = { type: "Delete" /* DELETE */, entries: [e] };
                  this.notifyAll(Array.from(this.entries.values()), delta);
              }
          }
      };
      /**
       * @param e The elements to be deleted if it satisfies the predicate
       */
      Slice.prototype.deleteN = function () {
          var e = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              e[_i] = arguments[_i];
          }
          this.deleteA(e);
      };
      /**
       * @param e The elements to be deleted if they satisfy the predicate
       */
      Slice.prototype.deleteA = function (e) {
          var _this = this;
          var d = [];
          e.forEach(function (e) {
              if (_this.predicate(e)) {
                  var id = e[_this.config.guidKey];
                  d.push(_this.entries.get(id));
                  _this.entries.delete(id);
              }
          });
          var delta = { type: "Delete" /* DELETE */, entries: d };
          this.notifyAll(__spreadArray([], __read(Array.from(this.entries.values()))), delta);
      };
      /**
       * Update the slice when an Entity instance mutates.
       *
       * @param e The element to be added or deleted depending on predicate reevaluation
       */
      Slice.prototype.put = function (e) {
          if (isArray(e)) {
              this.putA(e);
          }
          else {
              var id = e[this.config.guidKey];
              if (this.entries.get(id)) {
                  if (!this.predicate(e)) {
                      //Note that this is a ActionTypes.DELETE because we are removing the
                      //entity from the slice.
                      var delta = { type: "Delete" /* DELETE */, entries: [e] };
                      this.entries.delete(id);
                      this.notifyAll(__spreadArray([], __read(Array.from(this.entries.values()))), delta);
                  }
              }
              else if (this.predicate(e)) {
                  this.entries.set(id, e);
                  var delta = { type: "Put" /* PUT */, entries: [e] };
                  this.notifyAll(__spreadArray([], __read(Array.from(this.entries.values()))), delta);
              }
          }
      };
      /**
       * Update the slice with mutated Entity instances.
       *
       * @param e The elements to be deleted if it satisfies the predicate
       */
      Slice.prototype.putN = function () {
          var e = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              e[_i] = arguments[_i];
          }
          this.putA(e);
      };
      /**
       * @param e The elements to be put
       */
      Slice.prototype.putA = function (e) {
          var _this = this;
          var d = []; //instances to delete
          var u = []; //instances to update
          e.forEach(function (e) {
              var id = e[_this.config.guidKey];
              if (_this.entries.get(id)) {
                  if (!_this.predicate(e)) {
                      d.push(_this.entries.get(id));
                  }
              }
              else if (_this.predicate(e)) {
                  u.push(e);
              }
          });
          if (d.length > 0) {
              d.forEach(function (e) {
                  _this.entries.delete(e[_this.config.guidKey]);
              });
              var delta = { type: "Delete" /* DELETE */, entries: d };
              this.notifyAll(__spreadArray([], __read(Array.from(this.entries.values()))), delta);
          }
          if (u.length > 0) {
              u.forEach(function (e) {
                  _this.entries.set(e[_this.config.guidKey], e);
              });
              var delta = { type: "Put" /* PUT */, entries: u };
              this.notifyAll(__spreadArray([], __read(Array.from(this.entries.values()))), delta);
          }
      };
      /**
       * Resets the slice to empty.
       */
      Slice.prototype.reset = function () {
          var delta = {
              type: "Reset" /* RESET */,
              entries: __spreadArray([], __read(Array.from(this.entries.values())))
          };
          this.notifyAll([], delta);
          this.entries = new Map();
      };
      /**
       * Utility method that applies the predicate to an array
       * of entities and return the ones that pass the test.
       *
       * Used to create an initial set of values
       * that should be part of the `Slice`.
       *
       * @param p
       * @param e
       * @return The the array of entities that pass the predicate test.
       */
      Slice.prototype.test = function (p, e) {
          var v = [];
          e.forEach(function (e) {
              if (p(e)) {
                  v.push(e);
              }
          });
          return v;
      };
      return Slice;
  }(AbstractStore));

  /**
   * This `todoFactory` code will be used to illustrate the API examples.  The following
   * utilities are used in the tests and the API Typedoc examples contained here.
   * @example Utilities for API Examples
  ```
  export const enum TodoSliceEnum {
    COMPLETE = "Complete",
    INCOMPLETE = "Incomplete"
  }

  export class Todo {
    constructor(public complete: boolean, public title: string,public gid?:string, public id?:string) {}
  }

  export let todos = [new Todo(false, "You complete me!"), new Todo(true, "You completed me!")];

  export function todosFactory():Todo[] {
    return [new Todo(false, "You complete me!"), new Todo(true, "You completed me!")];
  }
   ```
   */
  var EStore = /** @class */ (function (_super) {
      __extends(EStore, _super);
      /**
       * Store constructor (Initialization with element is optional)
       *
       * perform initial notification to all observers,
       * such that function like {@link combineLatest}{}
       * will execute at least once.
       * @param entities
       * @example Dynamic `EStore<Todo>` Creation
    ```
    // Initialize the Store
    let store: EStore<Todo> = new EStore<Todo>(todosFactory());
    ```*/
      function EStore(entities, config) {
          if (entities === void 0) { entities = []; }
          var _this = _super.call(this, config) || this;
          /**
           * An Observable<E[]> reference so that
           *
           */
          _this.observable = _this.observe();
          /**
           * Notifies observers when the store is empty.
           */
          _this.notifyActive = new rxjs.ReplaySubject(1);
          /**
           * `Map` of active entties. The instance is public and can be used
           * directly to add and remove active entities, however we recommend
           * using the {@link addActive} and {@link deleteActive} methods.
           */
          _this.active = new Map();
          /**
           * Notifies observers when the store is loading.
           *
           * This is a common pattern found when implementing
           * `Observable` data sources.
           */
          _this.notifyLoading = new rxjs.ReplaySubject(1);
          /**
           * The current loading state.  Use loading when fetching new
           * data for the store.  The default loading state is `true`.
           *
           * This is such that if data is fetched asynchronously
           * in a service, components can wait on loading notification
           * before attempting to retrieve data from the service.
           *
           * Loading could be based on a composite response.  For example
           * when the stock and mutual funds have loaded, set loading to `false`.
           */
          _this._loading = true;
          /**
           * Notifies observers that a search is in progress.
           *
           * This is a common pattern found when implementing
           * `Observable` data sources.
           */
          _this.notifySearching = new rxjs.ReplaySubject(1);
          /**
           * The current `searching` state.  Use `searching`
           * for example to display a spinnner
           * when performing a search.
           * The default `searching` state is `false`.
           */
          _this._searching = false;
          /**
           * Store slices
           */
          _this.slices = new Map();
          var delta = { type: "Initialize" /* INTIALIZE */, entries: entities };
          _this.post(entities);
          _this.notifyDelta.next(delta);
          return _this;
      }
      /**
       * Calls complete on all {@link BehaviorSubject} instances.
       *
       * Call destroy when disposing of the store.
       */
      EStore.prototype.destroy = function () {
          _super.prototype.destroy.call(this);
          this.notifyLoading.complete();
          this.notifyActive.complete();
          this.slices.forEach(function (slice) { return slice.destroy(); });
      };
      /**
       * Toggles the entity:
       *
       * If the store contains the entity
       * it will be deleted.  If the store
       * does not contains the entity,
       * it is added.
       * @param e
       * @example Toggle the `Todo` instance
    ```
    estore.post(todo);
    // Remove todo
    estore.toggle(todo);
    // Add it back
    estore.toggle(todo);
    
    ```
       */
      EStore.prototype.toggle = function (e) {
          if (this.contains(e)) {
              this.delete(e);
          }
          else {
              this.post(e);
          }
      };
      /**
       * Add multiple entity entities to active.
       *
       * If the entity is not contained in the store it is added
       * to the store before it is added to `active`.
       *
       * Also we clone the map prior to broadcasting it with
       * `notifyActive` to make sure we will trigger Angular
       * change detection in the event that it maintains
       * a reference to the `active` state `Map` instance.
       *
       * @example Add a `todo1` and `todo2` as active
    ```
    addActive(todo1);
    addActive(todo2);
    ```
       */
      EStore.prototype.addActive = function (e) {
          if (this.contains(e)) {
              this.active.set(e.gid, e);
              this.notifyActive.next(new Map(this.active));
          }
          else {
              this.post(e);
              this.active.set(e.gid, e);
              this.notifyActive.next(new Map(this.active));
          }
      };
      /**
       * Delete an entity as active.
       *
       * Also we clone the map prior to broadcasting it with
       * `notifyActive` to make sure we will trigger Angular
       * change detection in the event that it maintains
       * a reference to the `active` state `Map` instance.
       *
       * @example Mark a `todo` instance as active
      ```
    deleteActive(todo1);
    deleteActive(todo2);
      ```
       */
      EStore.prototype.deleteActive = function (e) {
          this.active.delete(e.gid);
          this.notifyActive.next(new Map(this.active));
      };
      /**
       * Clear / reset the active entity map.
       *
       * Also we clone the map prior to broadcasting it with
       * `notifyActive` to make sure we will trigger Angular
       * change detection in the event that it maintains
       * a reference to the `active` state `Map` instance.
       *
       * @example Mark a `todo` instance as active
      ```
    deleteActive(todo1);
    deleteActive(todo2);
      ```
       */
      EStore.prototype.clearActive = function () {
          this.active.clear();
          this.notifyActive.next(new Map(this.active));
      };
      /**
       * Observe the active entity.
       * @example
         <pre>
        let active$ = source.observeActive();
        </pre>
      */
      EStore.prototype.observeActive = function () {
          return this.notifyActive.asObservable();
      };
      Object.defineProperty(EStore.prototype, "loading", {
          /**
           * @return A snapshot of the loading state.
           */
          get: function () {
              return this._loading;
          },
          /**
           * Sets the current loading state and notifies observers.
           */
          set: function (loading) {
              this._loading = loading;
              this.notifyLoading.next(this._loading);
          },
          enumerable: false,
          configurable: true
      });
      /**
       * Observe loading.
       * @example
         <pre>
        let loading$ = source.observeLoading();
        </pre>
    
        Note that this obverable piped through
        `takeWhile(v->v, true), such that it will
        complete after each emission.
    
        See:
        https://medium.com/@ole.ersoy/waiting-on-estore-to-load-8dcbe161613c
    
        For more details.
      */
      EStore.prototype.observeLoading = function () {
          return this.notifyLoading.asObservable().
              pipe(operators.takeWhile(function (v) { return v; }, true));
      };
      /**
       * Notfiies when loading has completed.
       */
      EStore.prototype.observeLoadingComplete = function () {
          return this.observeLoading().pipe(operators.filter(function (loading) { return loading == false; }), operators.switchMap(function () { return rxjs.of(true); }));
      };
      Object.defineProperty(EStore.prototype, "searching", {
          /**
           * @return A snapshot of the searching state.
           */
          get: function () {
              return this._searching;
          },
          /**
           * Sets the current searching state and notifies observers.
           */
          set: function (searching) {
              this._searching = searching;
              this.notifySearching.next(this._searching);
          },
          enumerable: false,
          configurable: true
      });
      /**
       * Observe searching.
       * @example
         <pre>
        let searching$ = source.observeSearching();
        </pre>
      
        Note that this obverable piped through
        `takeWhile(v->v, true), such that it will
        complete after each emission.
      
        See:
        https://medium.com/@ole.ersoy/waiting-on-estore-to-load-8dcbe161613c
      
        For more details.
      */
      EStore.prototype.observeSearching = function () {
          return this.notifySearching.asObservable().
              pipe(operators.takeWhile(function (v) { return v; }, true));
      };
      /**
       * Notfiies when searching has completed.
       */
      EStore.prototype.observeSearchingComplete = function () {
          return this.observeSearching().pipe(operators.filter(function (searching) { return searching == false; }), operators.switchMap(function () { return rxjs.of(true); }));
      };
      /**
       * Adds a slice to the store and keys it by the slices label.
       *
       * @param p
       * @param label
       *
       * @example Setup a Todo Slice for COMPLETE Todos
    ```
    source.addSlice(todo => todo.complete, TodoSlices.COMPLETE);
    ```
       */
      EStore.prototype.addSlice = function (p, label) {
          var slice = new Slice(label, p, this);
          this.slices.set(slice.label, slice);
      };
      /**
       * Remove a slice
       * @param label The label identifying the slice
       *
       * @example Remove the TodoSlices.COMPLETE Slice
    ```
    source.removeSlice(TodoSlices.COMPLETE);
    ```
       */
      EStore.prototype.removeSlice = function (label) {
          this.slices.delete(label);
      };
      /**
       * Get a slice
       * @param label The label identifying the slice
       * @return The Slice instance or undefined
       *
       * @example Get the TodoSlices.COMPLETE slice
    ```
    source.getSlice(TodoSlices.COMPLETE);
    ```
       */
      EStore.prototype.getSlice = function (label) {
          return this.slices.get(label);
      };
      /**
       * Post (Add a new) element(s) to the store.
       * @param e An indiidual entity or an array of entities
       * @example Post a `todo`.
    ```
    store.post(todo);
    ```
       */
      EStore.prototype.post = function (e) {
          if (!Array.isArray(e)) {
              var guid = e[this.GUID_KEY]
                  ? e[this.GUID_KEY]
                  : GUID();
              e[this.GUID_KEY] = guid;
              this.entries.set(guid, e);
              this.updateIDEntry(e);
              Array.from(this.slices.values()).forEach(function (s) {
                  s.post(e);
              });
              //Create a new array reference to trigger Angular change detection.
              var v = __spreadArray([], __read(Array.from(this.entries.values())));
              var delta = { type: "Post" /* POST */, entries: [e] };
              this.notifyAll(v, delta);
          }
          else {
              this.postA(e);
          }
      };
      /**
       * Post elements to the store.
       * @param ...e
       * @example Post two `Todo` instances.
    ```
    store.post(todo1, todo2);
    ```
       */
      EStore.prototype.postN = function () {
          var _this = this;
          var e = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              e[_i] = arguments[_i];
          }
          e.forEach(function (e) {
              var guid = e[_this.GUID_KEY]
                  ? e[_this.GUID_KEY]
                  : GUID();
              e[_this.GUID_KEY] = guid;
              _this.entries.set(guid, e);
              _this.updateIDEntry(e);
          });
          Array.from(this.slices.values()).forEach(function (s) {
              s.postA(e);
          });
          //Create a new array reference to trigger Angular change detection.
          var v = __spreadArray([], __read(Array.from(this.entries.values())));
          var delta = { type: "Post" /* POST */, entries: e };
          this.notifyAll(v, delta);
      };
      /**
       * Post (Add) an array of elements to the store.
       * @param e
       * @example Post a `Todo` array.
    ```
    store.post([todo1, todo2]);
    ```
       */
      EStore.prototype.postA = function (e) {
          this.postN.apply(this, __spreadArray([], __read(e)));
      };
      /**
       * Put (Update) an element.
       * @param e
       * @example Put a Todo instance.
    ```
    store.put(todo1);
    ```
       */
      EStore.prototype.put = function (e) {
          if (!Array.isArray(e)) {
              var id = e[this.GUID_KEY];
              this.entries.set(id, e);
              this.updateIDEntry(e);
              var v = __spreadArray([], __read(Array.from(this.entries.values())));
              this.notify.next(v);
              var delta = { type: "Put" /* PUT */, entries: [e] };
              this.notifyDelta.next(delta);
              Array.from(this.slices.values()).forEach(function (s) {
                  s.put(e);
              });
          }
          else {
              this.putA(e);
          }
      };
      /**
       * Put (Update) an element or add an element that was read from a persistence source
       * and thus already has an assigned global id`.
       * @param e
       * @example Put Todo instances.
    ```
    store.put(todo1, todo2);
    ```
       */
      EStore.prototype.putN = function () {
          var e = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              e[_i] = arguments[_i];
          }
          this.putA(e);
      };
      /**
       * Put (Update) the array of elements.
       * @param e
       * @example Put Todo instances.
    ```
    store.put([todo1, todo2]);
    ```
       */
      EStore.prototype.putA = function (e) {
          var _this = this;
          e.forEach(function (e) {
              var guid = e[_this.GUID_KEY];
              _this.entries.set(guid, e);
              _this.updateIDEntry(e);
          });
          //Create a new array reference to trigger Angular change detection.
          var v = __spreadArray([], __read(Array.from(this.entries.values())));
          this.notify.next(v);
          var delta = { type: "Put" /* PUT */, entries: e };
          this.notifyDelta.next(delta);
          Array.from(this.slices.values()).forEach(function (s) {
              s.putA(e);
          });
      };
      /**
       * Delete (Update) the array of elements.
       * @param e
       * @example Delete todo1.
    ```
    store.delete(todo1]);
    ```
       */
      EStore.prototype.delete = function (e) {
          if (!Array.isArray(e)) {
              this.deleteActive(e);
              var guid_1 = e[this.GUID_KEY];
              this.entries.delete(guid_1);
              this.deleteIDEntry(e);
              Array.from(this.slices.values()).forEach(function (s) {
                  s.entries.delete(guid_1);
              });
              //Create a new array reference to trigger Angular change detection.
              var v = __spreadArray([], __read(Array.from(this.entries.values())));
              var delta = { type: "Delete" /* DELETE */, entries: [e] };
              this.notifyAll(v, delta);
              Array.from(this.slices.values()).forEach(function (s) {
                  s.delete(e);
              });
          }
          else {
              this.deleteA(e);
          }
      };
      /**
       * Delete N elements.
       * @param ...e
       * @example Put Todo instances.
    ```
    store.delete(todo1, todo2);
    ```
       */
      EStore.prototype.deleteN = function () {
          var e = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              e[_i] = arguments[_i];
          }
          this.deleteA(e);
      };
      /**
       * Delete N elements.
       * @param ...e
       * @example Put Todo instances.
    ```
    store.delete(todo1, todo2);
    ```
       */
      EStore.prototype.deleteA = function (e) {
          var _this = this;
          e.forEach(function (e) {
              _this.deleteActive(e);
              var guid = e[_this.GUID_KEY];
              _this.entries.delete(guid);
              _this.deleteIDEntry(e);
              Array.from(_this.slices.values()).forEach(function (s) {
                  s.entries.delete(guid);
              });
          });
          //Create a new array reference to trigger Angular change detection.
          var v = __spreadArray([], __read(Array.from(this.entries.values())));
          var delta = { type: "Delete" /* DELETE */, entries: e };
          this.notifyAll(v, delta);
          Array.from(this.slices.values()).forEach(function (s) {
              s.deleteA(e);
          });
      };
      /**
       * Delete elements by {@link Predicate}.
       * @param p The predicate.
       * @example Put Todo instances.
    ```
    store.delete(todo1, todo2);
    ```
       */
      EStore.prototype.deleteP = function (p) {
          var _this = this;
          var d = [];
          Array.from(this.entries.values()).forEach(function (e) {
              if (p(e)) {
                  d.push(e);
                  var id = e[_this.GUID_KEY];
                  _this.entries.delete(id);
                  _this.deleteActive(e);
                  _this.deleteIDEntry(e);
              }
          });
          //Create a new array reference to trigger Angular change detection.
          var v = __spreadArray([], __read(Array.from(this.entries.values())));
          var delta = { type: "Delete" /* DELETE */, entries: d };
          this.notifyAll(v, delta);
          Array.from(this.slices.values()).forEach(function (s) {
              s.deleteA(d);
          });
      };
      /**
       * If the entity has the `id` key initialized with a value,
       * then also add the entity to the `idEntries`.
       *
       * @param e The element to be added to the `idEntries`.
       */
      EStore.prototype.updateIDEntry = function (e) {
          if (e[this.ID_KEY]) {
              this.idEntries.set(e[this.ID_KEY], e);
          }
      };
      /**
       * If the entity has the `id` key initialized with a value,
       * then also delete the entity to the `idEntries`.
       *
       * @param e The element to be added to the `idEntries`.
       */
      EStore.prototype.deleteIDEntry = function (e) {
          if (e[this.ID_KEY]) {
              this.idEntries.delete(e[this.ID_KEY]);
          }
      };
      /**
       * Resets the store and all contained slice instances to empty.
       * Also perform delta notification that sends all current store entries.
       * The ActionType.RESET code is sent with the delta notification.  Slices
       * send their own delta notification.
       *
       * @example Reset the store.
    ```
    store.reset();
    ```
       */
      EStore.prototype.reset = function () {
          var delta = {
              type: "Reset" /* RESET */,
              entries: Array.from(this.entries.values())
          };
          this.notifyAll([], delta);
          this.entries = new Map();
          Array.from(this.slices.values()).forEach(function (s) {
              s.reset();
          });
      };
      /**
       * Call all the notifiers at once.
       *
       * @param v
       * @param delta
       */
      EStore.prototype.notifyAll = function (v, delta) {
          _super.prototype.notifyAll.call(this, v, delta);
          this.notifyLoading.next(this.loading);
      };
      return EStore;
  }(AbstractStore));

  var OStore = /** @class */ (function () {
      function OStore(start) {
          var _this = this;
          /**
           * Map of Key Value pair entries
           * containing values store in this store.
           */
          this.entries = new Map();
          /**
           * Map of replay subject id to `ReplaySubject` instance.
           */
          this.subjects = new Map();
          if (start) {
              this.S = start;
              var keys = Object.keys(start);
              keys.forEach(function (k) {
                  var ovr = start[k];
                  _this.post(ovr, ovr.value);
                  ovr.obs = _this.observe(ovr);
              });
          }
      }
      /**
       * Reset the state of the OStore to the
       * values or reset provided in the constructor
       * {@link OStoreStart} instance.
       */
      OStore.prototype.reset = function () {
          var _this = this;
          if (this.S) {
              var keys = Object.keys(this.S);
              keys.forEach(function (k) {
                  var ovr = _this.S[k];
                  _this.put(ovr, ovr.reset ? ovr.reset : ovr.value);
              });
          }
      };
      /**
       * Clear all entries
       */
      OStore.prototype.clear = function () {
          this.entries.clear();
      };
      /**
       * Set create a key value pair entry and creates a
       * corresponding replay subject instance that will
       * be used to broadcast updates.
       *
       * @param key The key identifying the value
       * @param value The value
       */
      OStore.prototype.post = function (key, value) {
          this.entries.set(key, value);
          this.subjects.set(key, new rxjs.ReplaySubject(1));
          //Emit immediately so that Observers can receive 
          //the value straight away.
          var subject = this.subjects.get(key);
          if (subject) {
              subject.next(value);
          }
      };
      /**
       * Update a value and notify subscribers.
       *
       * @param key
       * @param value
       */
      OStore.prototype.put = function (key, value) {
          this.entries.set(key, value);
          var subject = this.subjects.get(key);
          if (subject) {
              subject.next(value);
          }
      };
      /**
       * Deletes both the value entry and the corresponding {@link ReplaySubject}.
       * Will unsubscribe the {@link ReplaySubject} prior to deleting it,
       * severing communication with corresponding {@link Observable}s.
       *
       * @param key
       */
      OStore.prototype.delete = function (key) {
          this.entries.delete(key);
          this.subjects.delete(key);
          var subject = this.subjects.get(key);
          if (subject) {
              subject.unsubscribe();
          }
      };
      /**
       * Observe changes to the values.
       *
       * @param key
       * @return An {@link Observable} of the value
       */
      OStore.prototype.observe = function (key) {
          return this.subjects.get(key).asObservable();
      };
      /**
        * Check whether a value exists.
        *
        * @param key
        * @return True if the entry exists ( Is not null or undefined ) and false otherwise.
        */
      OStore.prototype.exists = function (key) {
          return this.entries.get(key) != null;
      };
      /**
       * Retrieve a snapshot of the
       * value.
       *
       * @param key
       * @return A snapshot of the value corresponding to the key.
       */
      OStore.prototype.snapshot = function (key) {
          return this.entries.get(key);
      };
      /**
       * Indicates whether the store is empty.
       * @return true if the store is empty, false otherwise.
       */
      OStore.prototype.isEmpty = function () {
          return Array.from(this.entries.values()).length == 0;
      };
      /**
       * Returns the number of key value pairs contained.
       *
       * @return the number of entries in the store.
       */
      OStore.prototype.count = function () {
          return Array.from(this.entries.values()).length;
      };
      return OStore;
  }());

  /*
   * Public API Surface of slice
   */

  /**
   * Generated bundle index. Do not edit.
   */

  exports.AbstractStore = AbstractStore;
  exports.ESTORE_CONFIG_DEFAULT = ESTORE_CONFIG_DEFAULT;
  exports.EStore = EStore;
  exports.Entity = Entity;
  exports.GUID = GUID;
  exports.OStore = OStore;
  exports.SCROLL_UP_DEBOUNCE_TIME_20 = SCROLL_UP_DEBOUNCE_TIME_20;
  exports.SEARCH_DEBOUNCE_TIME_300 = SEARCH_DEBOUNCE_TIME_300;
  exports.Slice = Slice;
  exports.attachGUID = attachGUID;
  exports.attachGUIDs = attachGUIDs;
  exports.deepCopy = deepCopy;
  exports.distinct = distinct;
  exports.excludeKeys = excludeKeys;
  exports.getActiveValue = getActiveValue;
  exports.mapEntity = mapEntity;
  exports.scrollingUp = scrollingUp;
  exports.search = search;
  exports.shallowCopy = shallowCopy;
  exports.unique = unique;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=fireflysemantics-slice.umd.js.map
