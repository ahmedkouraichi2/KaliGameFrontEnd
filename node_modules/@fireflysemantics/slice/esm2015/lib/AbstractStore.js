import { ReplaySubject } from "rxjs";
import { map } from "rxjs/operators";
const { freeze } = Object;
const ESTORE_DEFAULT_ID_KEY = "id";
const ESTORE_DEFAULT_GID_KEY = "gid";
export const ESTORE_CONFIG_DEFAULT = freeze({
    idKey: ESTORE_DEFAULT_ID_KEY,
    guidKey: ESTORE_DEFAULT_GID_KEY
});
export class AbstractStore {
    constructor(config) {
        /**
         * Notifies observers of the store query.
         */
        this.notifyQuery = new ReplaySubject(1);
        /**
         * The current query state.
         */
        this._query = '';
        /**
         * Primary index for the stores elements.
         */
        this.entries = new Map();
        /**
         * The element entries that are keyed by
         * an id generated on the server.
         */
        this.idEntries = new Map();
        /**
         * Create notifications that broacast
         * the entire set of entries.
         */
        this.notify = new ReplaySubject(1);
        /**
         * Create notifications that broacast
         * store or slice delta state changes.
         */
        this.notifyDelta = new ReplaySubject(1);
        this.config = config
            ? freeze(Object.assign(Object.assign({}, ESTORE_CONFIG_DEFAULT), config))
            : ESTORE_CONFIG_DEFAULT;
    }
    /**
     * Sets the current query state and notifies observers.
     */
    set query(query) {
        this._query = query;
        this.notifyQuery.next(this._query);
    }
    /**
     * @return A snapshot of the query state.
     */
    get query() {
        return this._query;
    }
    /**
     * Observe the query.
     * @example
       <pre>
      let query$ = source.observeQuery();
      </pre>
    */
    observeQuery() {
        return this.notifyQuery.asObservable();
    }
    /**
     * The current id key for the EStore instance.
     * @return this.config.idKey;
     */
    get ID_KEY() {
        return this.config.idKey;
    }
    /**
     * The current guid key for the EStore instance.
     * @return this.config.guidKey;
     */
    get GUID_KEY() {
        return this.config.guidKey;
    }
    /**
     * Call all the notifiers at once.
     *
     * @param v
     * @param delta
     */
    notifyAll(v, delta) {
        this.notify.next(v);
        this.notifyDelta.next(delta);
    }
    /**
     * Observe store state changes.
     * @param sort Optional sorting function yielding a sorted observable.
     * @example
  ```
  let todos$ = source.observe();
  //or with a sort by title function
  let todos$ = source.observe((a, b)=>(a.title > b.title ? -1 : 1));
  ```
    */
    observe(sort) {
        if (sort) {
            return this.notify.pipe(map((e) => e.sort(sort)));
        }
        return this.notify.asObservable();
    }
    /**
     * Observe delta updates.
     * @example
       <pre>
       let todos$ = source.observeDelta();
       </pre>
     */
    observeDelta() {
        return this.notifyDelta.asObservable();
    }
    /**
     * Check whether the store is empty.
     *
     * @return A hot {@link Observable} that indicates whether the store is empty.
     *
     * @example
      <pre>
      source.isEmpty();
      </pre>
    */
    isEmpty() {
        return this.notify.pipe(map((entries) => entries.length == 0));
    }
    /**
     * Check whether the store is empty.
     *
     * @return A snapshot that indicates whether the store is empty.
     *
     * @example
       <pre>
      source.isEmpty();
      </pre>
    */
    isEmptySnapshot() {
        return Array.from(this.entries.values()).length == 0;
    }
    /**
     * Returns the number of entries contained.
     * @param p The predicate to apply in order to filter the count
     */
    count(p) {
        if (p) {
            return this.notify.pipe(map((e) => e.reduce((total, e) => total + (p(e) ? 1 : 0), 0)));
        }
        return this.notify.pipe(map((entries) => entries.length));
    }
    /**
     * Returns a snapshot of the number of entries contained in the store.
     * @param p The predicate to apply in order to filter the count
     */
    countSnapshot(p) {
        if (p) {
            return Array.from(this.entries.values()).filter(p).length;
        }
        return Array.from(this.entries.values()).length;
    }
    /**
     * Snapshot of all entries.
     *
     * @return Snapshot array of all the elements the entities the store contains.
     *
     * @example Observe a snapshot of all the entities in the store.
  ```
  let selectedTodos:Todo[] = source.allSnapshot();
  ```
     */
    allSnapshot() {
        return Array.from(this.entries.values());
    }
    /**
     * Returns true if the entries contain the identified instance.
     *
     * @param target Either an instance of type `E` or a `guid` identifying the instance.
     * @param byId Whether the lookup should be performed with the `id` key rather than the `guid`.
     * @returns true if the instance identified by the guid exists, false otherwise.
     *
     * @example
       <pre>
       let contains:boolean = source.contains(guid);
       </pre>
     */
    contains(target) {
        if (typeof target === "string") {
            return this.entries.get(target) ? true : false;
        }
        const guid = target[this.config.guidKey];
        return this.entries.get(guid) ? true : false;
    }
    /**
     * Returns true if the entries contain the identified instance.
     *
     * @param target Either an instance of type `E` or a `id` identifying the instance.
     * @returns true if the instance identified by the `id` exists, false otherwise.
     *
     * @example
       <pre>
       let contains:boolean = source.contains(guid);
       </pre>
     */
    containsById(target) {
        if (typeof target === "string") {
            return this.idEntries.get(target) ? true : false;
        }
        const id = target[this.config.idKey];
        return this.idEntries.get(id) ? true : false;
    }
    /**
     * Find and return the entity identified by the GUID parameter
     * if it exists and return it.
     *
     * @param guid
     * @return The entity instance if it exists, null otherwise
     */
    findOne(guid) {
        return this.entries.get(guid);
    }
    /**
     * Find and return the entity identified by the ID parameter
     * if it exists and return it.
     *
     * @param id
     * @return The entity instance if it exists, null otherwise
     */
    findOneByID(id) {
        return this.idEntries.get(id);
    }
    /**
     * Snapshot of the entries that match the predicate.
     *
     * @param p The predicate used to query for the selection.
     * @return A snapshot array containing the entities that match the predicate.
     *
     * @example Select all the `Todo` instance where the `title` length is greater than 100.
  ```
  let todos:Todo[]=store.select(todo=>todo.title.length>100);
  ```
     */
    select(p) {
        const selected = [];
        Array.from(this.entries.values()).forEach(e => {
            if (p(e)) {
                selected.push(e);
            }
        });
        return selected;
    }
    /**
     * Compare entities by GUID
     * @param e1 The first entity
     * @param e2 The second entity
     * @return true if the two entities have equal GUID ids
     * @example Compare `todo1` with `todo2` by `gid`.
  ```
  if (equalsByGUID(todo1, todo2)){...};
  ```
     */
    equalsByGUID(e1, e2) {
        return e1[this.GUID_KEY] == e2[this.GUID_KEY];
    }
    /**
     * Compare entities by ID
     * @param e1 The first entity
     * @param e2 The second entity
     * @return true if the two entities have equal ID ids
     * @example Compare `todo1` with `todo2` by `id`.
  ```
  if (equalsByID(todo1, todo2)){...};
  ```
     */
    equalsByID(e1, e2) {
        return e1[this.ID_KEY] == e2[this.ID_KEY];
    }
    /**
     * Calls complete on all {@link BehaviorSubject} instances.
     *
     * Call destroy when disposing of the store.
     */
    destroy() {
        this.notify.complete();
        this.notifyDelta.complete();
        this.notifyQuery.complete();
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQWJzdHJhY3RTdG9yZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Byb2plY3RzL3NsaWNlL3NyYy9saWIvQWJzdHJhY3RTdG9yZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsYUFBYSxFQUFjLE1BQU0sTUFBTSxDQUFBO0FBQ2hELE9BQU8sRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQTtBQUlwQyxNQUFNLEVBQUUsTUFBTSxFQUFFLEdBQUcsTUFBTSxDQUFBO0FBRXpCLE1BQU0scUJBQXFCLEdBQUcsSUFBSSxDQUFBO0FBQ2xDLE1BQU0sc0JBQXNCLEdBQUcsS0FBSyxDQUFBO0FBRXBDLE1BQU0sQ0FBQyxNQUFNLHFCQUFxQixHQUFnQixNQUFNLENBQUM7SUFDdkQsS0FBSyxFQUFFLHFCQUFxQjtJQUM1QixPQUFPLEVBQUUsc0JBQXNCO0NBQ2hDLENBQUMsQ0FBQztBQUVILE1BQU0sT0FBZ0IsYUFBYTtJQU9oQyxZQUFZLE1BQW9CO1FBTWpDOztXQUVHO1FBQ08sZ0JBQVcsR0FBRyxJQUFJLGFBQWEsQ0FBUyxDQUFDLENBQUMsQ0FBQztRQUVyRDs7V0FFRztRQUNPLFdBQU0sR0FBVyxFQUFFLENBQUM7UUE0QzlCOztXQUVHO1FBQ0ksWUFBTyxHQUFtQixJQUFJLEdBQUcsRUFBRSxDQUFBO1FBRTFDOzs7V0FHRztRQUNJLGNBQVMsR0FBbUIsSUFBSSxHQUFHLEVBQUUsQ0FBQTtRQUU1Qzs7O1dBR0c7UUFDTyxXQUFNLEdBQUcsSUFBSSxhQUFhLENBQU0sQ0FBQyxDQUFDLENBQUE7UUFFNUM7OztXQUdHO1FBQ08sZ0JBQVcsR0FBRyxJQUFJLGFBQWEsQ0FBVyxDQUFDLENBQUMsQ0FBQTtRQTlFbkQsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNO1lBQ2xCLENBQUMsQ0FBQyxNQUFNLGlDQUFNLHFCQUFxQixHQUFLLE1BQU0sRUFBRztZQUNqRCxDQUFDLENBQUMscUJBQXFCLENBQUM7SUFD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QUMzRDtRQUNELE9BQU8sS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDO0lBQ2xELENBQUM7SUFFRDs7Ozs7Ozs7O09BU0c7SUFDSCxXQUFXO1FBQ1QsT0FBTyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQztJQUMzQyxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7O09BV0c7SUFDSCxRQUFRLENBQUMsTUFBa0I7UUFDekIsSUFBSSxPQUFPLE1BQU0sS0FBSyxRQUFRLEVBQUU7WUFDOUIsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7U0FDaEQ7UUFDRCxNQUFNLElBQUksR0FBaUIsTUFBTyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDeEQsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7SUFDL0MsQ0FBQztJQUVEOzs7Ozs7Ozs7O09BVUc7SUFDSCxZQUFZLENBQUMsTUFBa0I7UUFDN0IsSUFBSSxPQUFPLE1BQU0sS0FBSyxRQUFRLEVBQUU7WUFDOUIsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7U0FDbEQ7UUFDRCxNQUFNLEVBQUUsR0FBaUIsTUFBTyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDcEQsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7SUFDL0MsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILE9BQU8sQ0FBQyxJQUFZO1FBQ2xCLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDaEMsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILFdBQVcsQ0FBQyxFQUFVO1FBQ3BCLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDaEMsQ0FBQztJQUVEOzs7Ozs7Ozs7O09BVUc7SUFDSCxNQUFNLENBQUMsQ0FBZTtRQUNwQixNQUFNLFFBQVEsR0FBUSxFQUFFLENBQUM7UUFDekIsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFO1lBQzVDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO2dCQUNSLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDbEI7UUFDSCxDQUFDLENBQUMsQ0FBQztRQUNILE9BQU8sUUFBUSxDQUFDO0lBQ2xCLENBQUM7SUFFRDs7Ozs7Ozs7O09BU0c7SUFDSCxZQUFZLENBQUMsRUFBTSxFQUFFLEVBQU07UUFDekIsT0FBTyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDaEQsQ0FBQztJQUVEOzs7Ozs7Ozs7T0FTRztJQUNILFVBQVUsQ0FBQyxFQUFNLEVBQUUsRUFBTTtRQUN2QixPQUFPLEVBQUUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUM1QyxDQUFDO0lBQ0Q7Ozs7T0FJRztJQUNILE9BQU87UUFDTCxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDNUIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUM5QixDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSZXBsYXlTdWJqZWN0LCBPYnNlcnZhYmxlIH0gZnJvbSBcInJ4anNcIlxuaW1wb3J0IHsgbWFwIH0gZnJvbSBcInJ4anMvb3BlcmF0b3JzXCJcbmltcG9ydCB7IERlbHRhLCBQcmVkaWNhdGUgfSBmcm9tIFwiLi9tb2RlbHNcIlxuaW1wb3J0IHsgU3RvcmVDb25maWcgfSBmcm9tIFwiLi9tb2RlbHMvU3RvcmVDb25maWdcIlxuXG5jb25zdCB7IGZyZWV6ZSB9ID0gT2JqZWN0XG5cbmNvbnN0IEVTVE9SRV9ERUZBVUxUX0lEX0tFWSA9IFwiaWRcIlxuY29uc3QgRVNUT1JFX0RFRkFVTFRfR0lEX0tFWSA9IFwiZ2lkXCJcblxuZXhwb3J0IGNvbnN0IEVTVE9SRV9DT05GSUdfREVGQVVMVDogU3RvcmVDb25maWcgPSBmcmVlemUoe1xuICBpZEtleTogRVNUT1JFX0RFRkFVTFRfSURfS0VZLFxuICBndWlkS2V5OiBFU1RPUkVfREVGQVVMVF9HSURfS0VZXG59KTtcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEFic3RyYWN0U3RvcmU8RT4ge1xuXG4gIC8qKlxuICAgKiBUaGUgY29uZmlndXJhdGlvbiBmb3IgdGhlIHN0b3JlLlxuICAgKi9cbiAgIHB1YmxpYyBjb25maWc6IFN0b3JlQ29uZmlnO1xuXG4gICBjb25zdHJ1Y3Rvcihjb25maWc/OiBTdG9yZUNvbmZpZykge1xuICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZ1xuICAgICAgID8gZnJlZXplKHsgLi4uRVNUT1JFX0NPTkZJR19ERUZBVUxULCAuLi5jb25maWcgfSlcbiAgICAgICA6IEVTVE9SRV9DT05GSUdfREVGQVVMVDtcbiAgIH1cbiBcbiAgLyoqXG4gICAqIE5vdGlmaWVzIG9ic2VydmVycyBvZiB0aGUgc3RvcmUgcXVlcnkuXG4gICAqL1xuICBwcm90ZWN0ZWQgbm90aWZ5UXVlcnkgPSBuZXcgUmVwbGF5U3ViamVjdDxzdHJpbmc+KDEpO1xuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBxdWVyeSBzdGF0ZS5cbiAgICovXG4gIHByb3RlY3RlZCBfcXVlcnk6IHN0cmluZyA9ICcnO1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjdXJyZW50IHF1ZXJ5IHN0YXRlIGFuZCBub3RpZmllcyBvYnNlcnZlcnMuXG4gICAqL1xuICBzZXQgcXVlcnkocXVlcnk6IHN0cmluZykge1xuICAgIHRoaXMuX3F1ZXJ5ID0gcXVlcnk7XG4gICAgdGhpcy5ub3RpZnlRdWVyeS5uZXh0KHRoaXMuX3F1ZXJ5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIEEgc25hcHNob3Qgb2YgdGhlIHF1ZXJ5IHN0YXRlLlxuICAgKi9cbiAgZ2V0IHF1ZXJ5KCkge1xuICAgIHJldHVybiB0aGlzLl9xdWVyeTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPYnNlcnZlIHRoZSBxdWVyeS5cbiAgICogQGV4YW1wbGVcbiAgICAgPHByZT5cbiAgICBsZXQgcXVlcnkkID0gc291cmNlLm9ic2VydmVRdWVyeSgpO1xuICAgIDwvcHJlPlxuICAqL1xuICBwdWJsaWMgb2JzZXJ2ZVF1ZXJ5KCkge1xuICAgIHJldHVybiB0aGlzLm5vdGlmeVF1ZXJ5LmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cblxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgaWQga2V5IGZvciB0aGUgRVN0b3JlIGluc3RhbmNlLlxuICAgKiBAcmV0dXJuIHRoaXMuY29uZmlnLmlkS2V5O1xuICAgKi9cbiAgZ2V0IElEX0tFWSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5pZEtleVxuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBndWlkIGtleSBmb3IgdGhlIEVTdG9yZSBpbnN0YW5jZS5cbiAgICogQHJldHVybiB0aGlzLmNvbmZpZy5ndWlkS2V5O1xuICAgKi9cbiAgZ2V0IEdVSURfS0VZKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLmd1aWRLZXlcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmltYXJ5IGluZGV4IGZvciB0aGUgc3RvcmVzIGVsZW1lbnRzLlxuICAgKi9cbiAgcHVibGljIGVudHJpZXM6IE1hcDxzdHJpbmcsIEU+ID0gbmV3IE1hcCgpXG5cbiAgLyoqXG4gICAqIFRoZSBlbGVtZW50IGVudHJpZXMgdGhhdCBhcmUga2V5ZWQgYnlcbiAgICogYW4gaWQgZ2VuZXJhdGVkIG9uIHRoZSBzZXJ2ZXIuXG4gICAqL1xuICBwdWJsaWMgaWRFbnRyaWVzOiBNYXA8c3RyaW5nLCBFPiA9IG5ldyBNYXAoKVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgbm90aWZpY2F0aW9ucyB0aGF0IGJyb2FjYXN0XG4gICAqIHRoZSBlbnRpcmUgc2V0IG9mIGVudHJpZXMuXG4gICAqL1xuICBwcm90ZWN0ZWQgbm90aWZ5ID0gbmV3IFJlcGxheVN1YmplY3Q8RVtdPigxKVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgbm90aWZpY2F0aW9ucyB0aGF0IGJyb2FjYXN0XG4gICAqIHN0b3JlIG9yIHNsaWNlIGRlbHRhIHN0YXRlIGNoYW5nZXMuXG4gICAqL1xuICBwcm90ZWN0ZWQgbm90aWZ5RGVsdGEgPSBuZXcgUmVwbGF5U3ViamVjdDxEZWx0YTxFPj4oMSlcblxuICAvKipcbiAgICogQ2FsbCBhbGwgdGhlIG5vdGlmaWVycyBhdCBvbmNlLlxuICAgKlxuICAgKiBAcGFyYW0gdlxuICAgKiBAcGFyYW0gZGVsdGFcbiAgICovXG4gIHByb3RlY3RlZCBub3RpZnlBbGwodjogRVtdLCBkZWx0YTogRGVsdGE8RT4pIHtcbiAgICB0aGlzLm5vdGlmeS5uZXh0KHYpO1xuICAgIHRoaXMubm90aWZ5RGVsdGEubmV4dChkZWx0YSk7XG4gIH1cblxuICAvKipcbiAgICogT2JzZXJ2ZSBzdG9yZSBzdGF0ZSBjaGFuZ2VzLlxuICAgKiBAcGFyYW0gc29ydCBPcHRpb25hbCBzb3J0aW5nIGZ1bmN0aW9uIHlpZWxkaW5nIGEgc29ydGVkIG9ic2VydmFibGUuXG4gICAqIEBleGFtcGxlXG5gYGBcbmxldCB0b2RvcyQgPSBzb3VyY2Uub2JzZXJ2ZSgpO1xuLy9vciB3aXRoIGEgc29ydCBieSB0aXRsZSBmdW5jdGlvblxubGV0IHRvZG9zJCA9IHNvdXJjZS5vYnNlcnZlKChhLCBiKT0+KGEudGl0bGUgPiBiLnRpdGxlID8gLTEgOiAxKSk7XG5gYGBcbiAgKi9cbiAgcHVibGljIG9ic2VydmUoc29ydD86IChhOiBhbnksIGI6IGFueSkgPT4gbnVtYmVyKTogT2JzZXJ2YWJsZTxFW10+IHtcbiAgICBpZiAoc29ydCkge1xuICAgICAgcmV0dXJuIHRoaXMubm90aWZ5LnBpcGUobWFwKChlOiBFW10pID0+IGUuc29ydChzb3J0KSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5ub3RpZnkuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICAvKipcbiAgICogT2JzZXJ2ZSBkZWx0YSB1cGRhdGVzLlxuICAgKiBAZXhhbXBsZVxuICAgICA8cHJlPlxuICAgICBsZXQgdG9kb3MkID0gc291cmNlLm9ic2VydmVEZWx0YSgpO1xuICAgICA8L3ByZT5cbiAgICovXG4gIHB1YmxpYyBvYnNlcnZlRGVsdGEoKTogT2JzZXJ2YWJsZTxEZWx0YTxFPj4ge1xuICAgIHJldHVybiB0aGlzLm5vdGlmeURlbHRhLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgdGhlIHN0b3JlIGlzIGVtcHR5LlxuICAgKiBcbiAgICogQHJldHVybiBBIGhvdCB7QGxpbmsgT2JzZXJ2YWJsZX0gdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgc3RvcmUgaXMgZW1wdHkuXG4gICAqIFxuICAgKiBAZXhhbXBsZVxuICAgIDxwcmU+XG4gICAgc291cmNlLmlzRW1wdHkoKTtcbiAgICA8L3ByZT5cbiAgKi9cbiAgaXNFbXB0eSgpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gdGhpcy5ub3RpZnkucGlwZShcbiAgICAgIG1hcCgoZW50cmllczogRVtdKSA9PiBlbnRyaWVzLmxlbmd0aCA9PSAwKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciB0aGUgc3RvcmUgaXMgZW1wdHkuXG4gICAqIFxuICAgKiBAcmV0dXJuIEEgc25hcHNob3QgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgc3RvcmUgaXMgZW1wdHkuXG4gICAqIFxuICAgKiBAZXhhbXBsZVxuICAgICA8cHJlPlxuICAgIHNvdXJjZS5pc0VtcHR5KCk7XG4gICAgPC9wcmU+XG4gICovXG4gIGlzRW1wdHlTbmFwc2hvdCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmVudHJpZXMudmFsdWVzKCkpLmxlbmd0aCA9PSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBlbnRyaWVzIGNvbnRhaW5lZC5cbiAgICogQHBhcmFtIHAgVGhlIHByZWRpY2F0ZSB0byBhcHBseSBpbiBvcmRlciB0byBmaWx0ZXIgdGhlIGNvdW50XG4gICAqL1xuICBjb3VudChwPzogUHJlZGljYXRlPEU+KTogT2JzZXJ2YWJsZTxudW1iZXI+IHtcbiAgICBpZiAocCkge1xuICAgICAgcmV0dXJuIHRoaXMubm90aWZ5LnBpcGUoXG4gICAgICAgIG1hcCgoZTogRVtdKSA9PiBlLnJlZHVjZSgodG90YWwsIGUpID0+IHRvdGFsICsgKHAoZSkgPyAxIDogMCksIDApKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubm90aWZ5LnBpcGUobWFwKChlbnRyaWVzOiBFW10pID0+IGVudHJpZXMubGVuZ3RoKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHNuYXBzaG90IG9mIHRoZSBudW1iZXIgb2YgZW50cmllcyBjb250YWluZWQgaW4gdGhlIHN0b3JlLlxuICAgKiBAcGFyYW0gcCBUaGUgcHJlZGljYXRlIHRvIGFwcGx5IGluIG9yZGVyIHRvIGZpbHRlciB0aGUgY291bnRcbiAgICovXG4gIGNvdW50U25hcHNob3QocD86IFByZWRpY2F0ZTxFPik6IG51bWJlciB7XG4gICAgaWYgKHApIHtcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuZW50cmllcy52YWx1ZXMoKSkuZmlsdGVyKHApLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5lbnRyaWVzLnZhbHVlcygpKS5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogU25hcHNob3Qgb2YgYWxsIGVudHJpZXMuXG4gICAqIFxuICAgKiBAcmV0dXJuIFNuYXBzaG90IGFycmF5IG9mIGFsbCB0aGUgZWxlbWVudHMgdGhlIGVudGl0aWVzIHRoZSBzdG9yZSBjb250YWlucy5cbiAgICogXG4gICAqIEBleGFtcGxlIE9ic2VydmUgYSBzbmFwc2hvdCBvZiBhbGwgdGhlIGVudGl0aWVzIGluIHRoZSBzdG9yZS5cbmBgYFxubGV0IHNlbGVjdGVkVG9kb3M6VG9kb1tdID0gc291cmNlLmFsbFNuYXBzaG90KCk7XG5gYGBcbiAgICovXG4gIGFsbFNuYXBzaG90KCk6IEVbXSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5lbnRyaWVzLnZhbHVlcygpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGVudHJpZXMgY29udGFpbiB0aGUgaWRlbnRpZmllZCBpbnN0YW5jZS5cbiAgICogXG4gICAqIEBwYXJhbSB0YXJnZXQgRWl0aGVyIGFuIGluc3RhbmNlIG9mIHR5cGUgYEVgIG9yIGEgYGd1aWRgIGlkZW50aWZ5aW5nIHRoZSBpbnN0YW5jZS4gXG4gICAqIEBwYXJhbSBieUlkIFdoZXRoZXIgdGhlIGxvb2t1cCBzaG91bGQgYmUgcGVyZm9ybWVkIHdpdGggdGhlIGBpZGAga2V5IHJhdGhlciB0aGFuIHRoZSBgZ3VpZGAuXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGluc3RhbmNlIGlkZW50aWZpZWQgYnkgdGhlIGd1aWQgZXhpc3RzLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIFxuICAgKiBAZXhhbXBsZVxuICAgICA8cHJlPlxuICAgICBsZXQgY29udGFpbnM6Ym9vbGVhbiA9IHNvdXJjZS5jb250YWlucyhndWlkKTtcbiAgICAgPC9wcmU+XG4gICAqL1xuICBjb250YWlucyh0YXJnZXQ6IEUgfCBzdHJpbmcpOmJvb2xlYW4ge1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbnRyaWVzLmdldCh0YXJnZXQpID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBndWlkOiBzdHJpbmcgPSAoPGFueT50YXJnZXQpW3RoaXMuY29uZmlnLmd1aWRLZXldO1xuICAgIHJldHVybiB0aGlzLmVudHJpZXMuZ2V0KGd1aWQpID8gdHJ1ZSA6IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZW50cmllcyBjb250YWluIHRoZSBpZGVudGlmaWVkIGluc3RhbmNlLlxuICAgKiBcbiAgICogQHBhcmFtIHRhcmdldCBFaXRoZXIgYW4gaW5zdGFuY2Ugb2YgdHlwZSBgRWAgb3IgYSBgaWRgIGlkZW50aWZ5aW5nIHRoZSBpbnN0YW5jZS4gXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGluc3RhbmNlIGlkZW50aWZpZWQgYnkgdGhlIGBpZGAgZXhpc3RzLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIFxuICAgKiBAZXhhbXBsZVxuICAgICA8cHJlPlxuICAgICBsZXQgY29udGFpbnM6Ym9vbGVhbiA9IHNvdXJjZS5jb250YWlucyhndWlkKTtcbiAgICAgPC9wcmU+XG4gICAqL1xuICBjb250YWluc0J5SWQodGFyZ2V0OiBFIHwgc3RyaW5nKTpib29sZWFuIHtcbiAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIHRoaXMuaWRFbnRyaWVzLmdldCh0YXJnZXQpID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBpZDogc3RyaW5nID0gKDxhbnk+dGFyZ2V0KVt0aGlzLmNvbmZpZy5pZEtleV07XG4gICAgcmV0dXJuIHRoaXMuaWRFbnRyaWVzLmdldChpZCkgPyB0cnVlIDogZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogRmluZCBhbmQgcmV0dXJuIHRoZSBlbnRpdHkgaWRlbnRpZmllZCBieSB0aGUgR1VJRCBwYXJhbWV0ZXJcbiAgICogaWYgaXQgZXhpc3RzIGFuZCByZXR1cm4gaXQuXG4gICAqXG4gICAqIEBwYXJhbSBndWlkXG4gICAqIEByZXR1cm4gVGhlIGVudGl0eSBpbnN0YW5jZSBpZiBpdCBleGlzdHMsIG51bGwgb3RoZXJ3aXNlXG4gICAqL1xuICBmaW5kT25lKGd1aWQ6IHN0cmluZyk6IEUgfCB1bmRlZmluZWR7XG4gICAgcmV0dXJuIHRoaXMuZW50cmllcy5nZXQoZ3VpZCk7XG4gIH1cblxuICAvKipcbiAgICogRmluZCBhbmQgcmV0dXJuIHRoZSBlbnRpdHkgaWRlbnRpZmllZCBieSB0aGUgSUQgcGFyYW1ldGVyXG4gICAqIGlmIGl0IGV4aXN0cyBhbmQgcmV0dXJuIGl0LlxuICAgKlxuICAgKiBAcGFyYW0gaWRcbiAgICogQHJldHVybiBUaGUgZW50aXR5IGluc3RhbmNlIGlmIGl0IGV4aXN0cywgbnVsbCBvdGhlcndpc2VcbiAgICovXG4gIGZpbmRPbmVCeUlEKGlkOiBzdHJpbmcpOiBFIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5pZEVudHJpZXMuZ2V0KGlkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTbmFwc2hvdCBvZiB0aGUgZW50cmllcyB0aGF0IG1hdGNoIHRoZSBwcmVkaWNhdGUuXG4gICAqXG4gICAqIEBwYXJhbSBwIFRoZSBwcmVkaWNhdGUgdXNlZCB0byBxdWVyeSBmb3IgdGhlIHNlbGVjdGlvbi5cbiAgICogQHJldHVybiBBIHNuYXBzaG90IGFycmF5IGNvbnRhaW5pbmcgdGhlIGVudGl0aWVzIHRoYXQgbWF0Y2ggdGhlIHByZWRpY2F0ZS5cbiAgICogXG4gICAqIEBleGFtcGxlIFNlbGVjdCBhbGwgdGhlIGBUb2RvYCBpbnN0YW5jZSB3aGVyZSB0aGUgYHRpdGxlYCBsZW5ndGggaXMgZ3JlYXRlciB0aGFuIDEwMC4gXG5gYGBcbmxldCB0b2RvczpUb2RvW109c3RvcmUuc2VsZWN0KHRvZG89PnRvZG8udGl0bGUubGVuZ3RoPjEwMCk7XG5gYGBcbiAgICovXG4gIHNlbGVjdChwOiBQcmVkaWNhdGU8RT4pOiBFW10ge1xuICAgIGNvbnN0IHNlbGVjdGVkOiBFW10gPSBbXTtcbiAgICBBcnJheS5mcm9tKHRoaXMuZW50cmllcy52YWx1ZXMoKSkuZm9yRWFjaChlID0+IHtcbiAgICAgIGlmIChwKGUpKSB7XG4gICAgICAgIHNlbGVjdGVkLnB1c2goZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHNlbGVjdGVkO1xuICB9XG5cbiAgLyoqIFxuICAgKiBDb21wYXJlIGVudGl0aWVzIGJ5IEdVSUQgXG4gICAqIEBwYXJhbSBlMSBUaGUgZmlyc3QgZW50aXR5XG4gICAqIEBwYXJhbSBlMiBUaGUgc2Vjb25kIGVudGl0eVxuICAgKiBAcmV0dXJuIHRydWUgaWYgdGhlIHR3byBlbnRpdGllcyBoYXZlIGVxdWFsIEdVSUQgaWRzXG4gICAqIEBleGFtcGxlIENvbXBhcmUgYHRvZG8xYCB3aXRoIGB0b2RvMmAgYnkgYGdpZGAuXG5gYGBcbmlmIChlcXVhbHNCeUdVSUQodG9kbzEsIHRvZG8yKSl7Li4ufTtcbmBgYFxuICAgKi9cbiAgZXF1YWxzQnlHVUlEKGUxOmFueSwgZTI6YW55KSB7XG4gICAgcmV0dXJuIGUxW3RoaXMuR1VJRF9LRVldID09IGUyW3RoaXMuR1VJRF9LRVldO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBhcmUgZW50aXRpZXMgYnkgSUQgXG4gICAqIEBwYXJhbSBlMSBUaGUgZmlyc3QgZW50aXR5XG4gICAqIEBwYXJhbSBlMiBUaGUgc2Vjb25kIGVudGl0eVxuICAgKiBAcmV0dXJuIHRydWUgaWYgdGhlIHR3byBlbnRpdGllcyBoYXZlIGVxdWFsIElEIGlkc1xuICAgKiBAZXhhbXBsZSBDb21wYXJlIGB0b2RvMWAgd2l0aCBgdG9kbzJgIGJ5IGBpZGAuXG5gYGBcbmlmIChlcXVhbHNCeUlEKHRvZG8xLCB0b2RvMikpey4uLn07XG5gYGBcbiAgICovXG4gIGVxdWFsc0J5SUQoZTE6YW55LCBlMjphbnkpIHtcbiAgICByZXR1cm4gZTFbdGhpcy5JRF9LRVldID09IGUyW3RoaXMuSURfS0VZXTtcbiAgfVxuICAvKipcbiAgICogQ2FsbHMgY29tcGxldGUgb24gYWxsIHtAbGluayBCZWhhdmlvclN1YmplY3R9IGluc3RhbmNlcy5cbiAgICogXG4gICAqIENhbGwgZGVzdHJveSB3aGVuIGRpc3Bvc2luZyBvZiB0aGUgc3RvcmUuXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMubm90aWZ5LmNvbXBsZXRlKCk7XG4gICAgdGhpcy5ub3RpZnlEZWx0YS5jb21wbGV0ZSgpO1xuICAgIHRoaXMubm90aWZ5UXVlcnkuY29tcGxldGUoKTtcbiAgfVxufSJdfQ==