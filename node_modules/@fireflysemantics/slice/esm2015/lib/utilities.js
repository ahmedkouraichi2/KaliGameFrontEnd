import { ESTORE_CONFIG_DEFAULT } from "./AbstractStore";
import { fromEvent, of } from 'rxjs';
import { switchMap, pairwise, debounceTime, distinctUntilChanged, map } from 'rxjs/operators';
import { nanoid } from "nanoid";
/**
 * Returns all the entities are distinct by the
 * `property` value argument.
 *
 * Note that the implementation uses a `Map<string, E>` to
 * index the entities by key.  Therefore the more recent occurences
 * matching a key instance will overwrite the previous ones.
 *
 * @param property The name of the property to check for distinct values by.
 * @param entities The entities in the array.
 *
 * @example
 ```
  let todos: Todo[] = [
    { id: 1, title: "Lets do it!" },
    { id: 1, title: "Lets do it again!" },
    { id: 2, title: "All done!" }
  ];

  let todos2: Todo[] = [
    { id: 1, title: "Lets do it!" },
    { id: 2, title: "All done!" }
  ];

  expect(distinct(todos, "id").length).toEqual(2);
  expect(distinct(todos2, "id").length).toEqual(2);

 ```
 */
export function distinct(entities, property) {
    const entitiesByProperty = new Map(entities.map(e => [e[property], e]));
    return Array.from(entitiesByProperty.values());
}
/**
 * Returns true if all the entities are distinct by the
 * `property` value argument.
 *
 * @param property The name of the property to check for distinct values by.
 * @param entities The entities in the array.
 *
 * @example
 *
 ```
  let todos: Todo[] = [
    { id: 1, title: "Lets do it!" },
    { id: 1, title: "Lets do it again!" },
    { id: 2, title: "All done!" }
  ];

  let todos2: Todo[] = [
    { id: 1, title: "Lets do it!" },
    { id: 2, title: "All done!" }
  ];

  expect(unique(todos, "id")).toBeFalsy();
  expect(unique(todos2, "id")).toBeTruthy();
 ```
 */
export function unique(entities, property) {
    return entities.length == distinct(entities, property).length ? true : false;
}
/**
 * Create a global ID
 * @return The global id.
 *
 * @example
 * let e.guid = GUID();
 */
export function GUID() {
    return nanoid();
}
/**
 * Set the global identfication property on the instance.
 *
 * @param e Entity we want to set the global identifier on.
 * @param gid The name of the `gid` property.  If not specified it defaults to `ESTORE_CONFIG_DEFAULT.guidKey`.
 */
export function attachGUID(e, gid) {
    const guidKey = gid ? gid : ESTORE_CONFIG_DEFAULT.guidKey;
    let id = nanoid();
    e[guidKey] = id;
    return id;
}
/**
 * Set the global identfication property on the instance.
 *
 * @param e[] Entity array we want to set the global identifiers on.
 * @param gid The name of the `gid` property.  If not specified it defaults to `gid`.
 */
export function attachGUIDs(e, gid) {
    e.forEach(e => {
        attachGUID(e, gid);
    });
}
/**
 * Create a shallow copy of the argument.
 * @param o The object to copy
 */
export function shallowCopy(o) {
    return Object.assign({}, o);
}
/**
 * Create a deep copy of the argument.
 * @param o The object to copy
 */
export function deepCopy(o) {
    return JSON.parse(JSON.stringify(o));
}
/**
 * Gets the current active value from the `active`
 * Map.
 *
 * This is used for the scenario where we are managing
 * a single active instance.  For example
 * when selecting a book from a collection of books.
 *
 * The selected `Book` instance becomes the active value.
 *
 * @example
 * const book:Book = getActiveValue(bookStore.active);
 * @param m
 */
export function getActiveValue(m) {
    if (m.size) {
        return m.entries().next().value[1];
    }
    return null;
}
/**
 * The method can be used to exclude keys from an instance
 * of type `E`.
 *
 * We can use this to exclude values when searching an object.
 *
 * @param entity An instance of type E
 * @param exclude The keys to exclude
 *
 * @example
 * todo = { id: '1', description: 'Do it!' }
 * let keys = excludeKeys<Todo>(todo, ['id]);
 * // keys = ['description']
 */
export function excludeKeys(entity, exclude) {
    const keys = Object.keys(entity);
    return keys.filter((key) => {
        return exclude.indexOf(key) < 0;
    });
}
/**
 *
 * @param entities The entity to search
 * @param exclude Keys to exclude from each entity
 *
 * @return E[] Array of entities with properties containing the search term.
 */
export function search(query = '', entities, exclude = []) {
    const { isArray } = Array;
    query = query.toLowerCase();
    return entities.filter(function (e) {
        //Do the keys calculation on each instance e:E
        //because an instance can have optional parameters,
        //and thus we have to check each instance, not just
        //the first one in the array.
        const keys = excludeKeys(e, exclude);
        return keys.some((key) => {
            const value = e[key];
            if (!value) {
                return false;
            }
            if (isArray(value)) {
                return value.some(v => {
                    return String(v).toLowerCase().includes(query);
                });
            }
            else {
                return String(value).toLowerCase().includes(query);
            }
        });
    });
}
/**
 * @param scrollable The element being scrolled
 * @param debounceMS The number of milliseconds to debounce scroll events
 * @param sp The function returning the scroll position coordinates.
 * @return A boolean valued observable indicating whether the element is scrolling up or down
 */
export function scrollingUp(scrollable, debounceMS, sp) {
    return fromEvent(scrollable, 'scroll').pipe(debounceTime(debounceMS), distinctUntilChanged(), map(v => sp()), pairwise(), switchMap(p => {
        const y1 = p[0][1];
        const y2 = p[1][1];
        return y1 - y2 > 0 ? of(false) : of(true);
    }));
}
/**
 * Filters the entities properties to the set contained in the
 * `keys` array.
 *
 * @param keys The array of keys that the entity be limited to
 * @param entity The entity to map
 * @return An entity instance that has only the keys provided in the keys array
 */
export function mapEntity(keys, entity) {
    const result = {};
    keys.forEach(k => {
        result[k] = entity[k];
    });
    return result;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbGl0aWVzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvc2xpY2Uvc3JjL2xpYi91dGlsaXRpZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDeEQsT0FBTyxFQUFjLFNBQVMsRUFBRSxFQUFFLEVBQUUsTUFBTSxNQUFNLENBQUE7QUFDaEQsT0FBTyxFQUFFLFNBQVMsRUFBRSxRQUFRLEVBQUUsWUFBWSxFQUFFLG9CQUFvQixFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFBO0FBQzdGLE9BQU8sRUFBRSxNQUFNLEVBQUMsTUFBTSxRQUFRLENBQUE7QUFHOUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0E0Qkc7QUFDSCxNQUFNLFVBQVUsUUFBUSxDQUF1QixRQUFhLEVBQUUsUUFBVztJQUN2RSxNQUFNLGtCQUFrQixHQUFHLElBQUksR0FBRyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQWMsQ0FBQyxDQUFDLENBQUM7SUFDckYsT0FBTyxLQUFLLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUM7QUFDakQsQ0FBQztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0F3Qkc7QUFDSCxNQUFNLFVBQVUsTUFBTSxDQUFJLFFBQWEsRUFBRSxRQUFpQjtJQUN4RCxPQUFPLFFBQVEsQ0FBQyxNQUFNLElBQUksUUFBUSxDQUFDLFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDO0FBQy9FLENBQUM7QUFFRDs7Ozs7O0dBTUc7QUFDSCxNQUFNLFVBQVUsSUFBSTtJQUNsQixPQUFPLE1BQU0sRUFB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QUFDO2FBQ3BEO1FBQ0gsQ0FBQyxDQUFDLENBQUE7SUFDSixDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUFFRDs7Ozs7R0FLRztBQUNILE1BQU0sVUFBVSxXQUFXLENBQ3pCLFVBQWUsRUFDZixVQUFrQixFQUNsQixFQUFrQjtJQUNsQixPQUFPLFNBQVMsQ0FBQyxVQUFVLEVBQUUsUUFBUSxDQUFDLENBQUMsSUFBSSxDQUN6QyxZQUFZLENBQUMsVUFBVSxDQUFDLEVBQ3hCLG9CQUFvQixFQUFFLEVBQ3RCLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQ2QsUUFBUSxFQUFFLEVBQ1YsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFFO1FBQ2QsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFBO1FBQ2xCLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQTtRQUNsQixPQUFPLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQTtJQUMzQyxDQUFDLENBQUMsQ0FBQyxDQUFBO0FBQ0wsQ0FBQztBQUVEOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLFVBQVUsU0FBUyxDQUFDLElBQWEsRUFBRSxNQUFVO0lBQ2pELE1BQU0sTUFBTSxHQUFPLEVBQUUsQ0FBQTtJQUNyQixJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQSxFQUFFO1FBQ2QsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQTtJQUN2QixDQUFDLENBQUMsQ0FBQTtJQUNGLE9BQU8sTUFBTSxDQUFBO0FBQ2YsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVTVE9SRV9DT05GSUdfREVGQVVMVCB9IGZyb20gXCIuL0Fic3RyYWN0U3RvcmVcIjtcbmltcG9ydCB7IE9ic2VydmFibGUsIGZyb21FdmVudCwgb2YgfSBmcm9tICdyeGpzJ1xuaW1wb3J0IHsgc3dpdGNoTWFwLCBwYWlyd2lzZSwgZGVib3VuY2VUaW1lLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnXG5pbXBvcnQgeyBuYW5vaWR9IGZyb20gXCJuYW5vaWRcIlxuaW1wb3J0IHsgc2Nyb2xsUG9zaXRpb24gfSBmcm9tIFwiLi9tb2RlbHMvc2Nyb2xsUG9zaXRpb25cIjtcblxuLyoqXG4gKiBSZXR1cm5zIGFsbCB0aGUgZW50aXRpZXMgYXJlIGRpc3RpbmN0IGJ5IHRoZSBcbiAqIGBwcm9wZXJ0eWAgdmFsdWUgYXJndW1lbnQuICBcbiAqIFxuICogTm90ZSB0aGF0IHRoZSBpbXBsZW1lbnRhdGlvbiB1c2VzIGEgYE1hcDxzdHJpbmcsIEU+YCB0b1xuICogaW5kZXggdGhlIGVudGl0aWVzIGJ5IGtleS4gIFRoZXJlZm9yZSB0aGUgbW9yZSByZWNlbnQgb2NjdXJlbmNlcyBcbiAqIG1hdGNoaW5nIGEga2V5IGluc3RhbmNlIHdpbGwgb3ZlcndyaXRlIHRoZSBwcmV2aW91cyBvbmVzLlxuICogXG4gKiBAcGFyYW0gcHJvcGVydHkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGNoZWNrIGZvciBkaXN0aW5jdCB2YWx1ZXMgYnkuXG4gKiBAcGFyYW0gZW50aXRpZXMgVGhlIGVudGl0aWVzIGluIHRoZSBhcnJheS5cbiAqIFxuICogQGV4YW1wbGVcbiBgYGBcbiAgbGV0IHRvZG9zOiBUb2RvW10gPSBbXG4gICAgeyBpZDogMSwgdGl0bGU6IFwiTGV0cyBkbyBpdCFcIiB9LFxuICAgIHsgaWQ6IDEsIHRpdGxlOiBcIkxldHMgZG8gaXQgYWdhaW4hXCIgfSxcbiAgICB7IGlkOiAyLCB0aXRsZTogXCJBbGwgZG9uZSFcIiB9XG4gIF07XG5cbiAgbGV0IHRvZG9zMjogVG9kb1tdID0gW1xuICAgIHsgaWQ6IDEsIHRpdGxlOiBcIkxldHMgZG8gaXQhXCIgfSxcbiAgICB7IGlkOiAyLCB0aXRsZTogXCJBbGwgZG9uZSFcIiB9XG4gIF07XG5cbiAgZXhwZWN0KGRpc3RpbmN0KHRvZG9zLCBcImlkXCIpLmxlbmd0aCkudG9FcXVhbCgyKTtcbiAgZXhwZWN0KGRpc3RpbmN0KHRvZG9zMiwgXCJpZFwiKS5sZW5ndGgpLnRvRXF1YWwoMik7XG5cbiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpc3RpbmN0PEUsIEsgZXh0ZW5kcyBrZXlvZiBFPihlbnRpdGllczogRVtdLCBwcm9wZXJ0eTogSyk6IEVbXSB7XG4gIGNvbnN0IGVudGl0aWVzQnlQcm9wZXJ0eSA9IG5ldyBNYXAoZW50aXRpZXMubWFwKGUgPT4gW2VbcHJvcGVydHldLCBlXSBhcyBbRVtLXSwgRV0pKTtcbiAgcmV0dXJuIEFycmF5LmZyb20oZW50aXRpZXNCeVByb3BlcnR5LnZhbHVlcygpKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYWxsIHRoZSBlbnRpdGllcyBhcmUgZGlzdGluY3QgYnkgdGhlIFxuICogYHByb3BlcnR5YCB2YWx1ZSBhcmd1bWVudC5cbiAqIFxuICogQHBhcmFtIHByb3BlcnR5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBjaGVjayBmb3IgZGlzdGluY3QgdmFsdWVzIGJ5LlxuICogQHBhcmFtIGVudGl0aWVzIFRoZSBlbnRpdGllcyBpbiB0aGUgYXJyYXkuXG4gKiBcbiAqIEBleGFtcGxlXG4gKiBcbiBgYGBcbiAgbGV0IHRvZG9zOiBUb2RvW10gPSBbXG4gICAgeyBpZDogMSwgdGl0bGU6IFwiTGV0cyBkbyBpdCFcIiB9LFxuICAgIHsgaWQ6IDEsIHRpdGxlOiBcIkxldHMgZG8gaXQgYWdhaW4hXCIgfSxcbiAgICB7IGlkOiAyLCB0aXRsZTogXCJBbGwgZG9uZSFcIiB9XG4gIF07XG5cbiAgbGV0IHRvZG9zMjogVG9kb1tdID0gW1xuICAgIHsgaWQ6IDEsIHRpdGxlOiBcIkxldHMgZG8gaXQhXCIgfSxcbiAgICB7IGlkOiAyLCB0aXRsZTogXCJBbGwgZG9uZSFcIiB9XG4gIF07XG5cbiAgZXhwZWN0KHVuaXF1ZSh0b2RvcywgXCJpZFwiKSkudG9CZUZhbHN5KCk7XG4gIGV4cGVjdCh1bmlxdWUodG9kb3MyLCBcImlkXCIpKS50b0JlVHJ1dGh5KCk7XG4gYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bmlxdWU8RT4oZW50aXRpZXM6IEVbXSwgcHJvcGVydHk6IGtleW9mIEUpOmJvb2xlYW4ge1xuICByZXR1cm4gZW50aXRpZXMubGVuZ3RoID09IGRpc3RpbmN0KGVudGl0aWVzLCBwcm9wZXJ0eSkubGVuZ3RoID8gdHJ1ZSA6IGZhbHNlO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGdsb2JhbCBJRFxuICogQHJldHVybiBUaGUgZ2xvYmFsIGlkLlxuICogXG4gKiBAZXhhbXBsZVxuICogbGV0IGUuZ3VpZCA9IEdVSUQoKTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEdVSUQoKSB7XG4gIHJldHVybiBuYW5vaWQoKTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGdsb2JhbCBpZGVudGZpY2F0aW9uIHByb3BlcnR5IG9uIHRoZSBpbnN0YW5jZS5cbiAqIFxuICogQHBhcmFtIGUgRW50aXR5IHdlIHdhbnQgdG8gc2V0IHRoZSBnbG9iYWwgaWRlbnRpZmllciBvbi5cbiAqIEBwYXJhbSBnaWQgVGhlIG5hbWUgb2YgdGhlIGBnaWRgIHByb3BlcnR5LiAgSWYgbm90IHNwZWNpZmllZCBpdCBkZWZhdWx0cyB0byBgRVNUT1JFX0NPTkZJR19ERUZBVUxULmd1aWRLZXlgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXR0YWNoR1VJRDxFPihlOiBFLCBnaWQ/OiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBndWlkS2V5ID0gZ2lkID8gZ2lkIDogRVNUT1JFX0NPTkZJR19ERUZBVUxULmd1aWRLZXlcbiAgbGV0IGlkOiBzdHJpbmcgPSBuYW5vaWQoKTtcbiAgKDxhbnk+ZSlbZ3VpZEtleV0gPSBpZFxuICByZXR1cm4gaWRcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGdsb2JhbCBpZGVudGZpY2F0aW9uIHByb3BlcnR5IG9uIHRoZSBpbnN0YW5jZS5cbiAqIFxuICogQHBhcmFtIGVbXSBFbnRpdHkgYXJyYXkgd2Ugd2FudCB0byBzZXQgdGhlIGdsb2JhbCBpZGVudGlmaWVycyBvbi5cbiAqIEBwYXJhbSBnaWQgVGhlIG5hbWUgb2YgdGhlIGBnaWRgIHByb3BlcnR5LiAgSWYgbm90IHNwZWNpZmllZCBpdCBkZWZhdWx0cyB0byBgZ2lkYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGF0dGFjaEdVSURzPEU+KGU6IEVbXSwgZ2lkPzogc3RyaW5nKSB7XG4gIGUuZm9yRWFjaChlID0+IHtcbiAgICBhdHRhY2hHVUlEKGUsIGdpZCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHNoYWxsb3cgY29weSBvZiB0aGUgYXJndW1lbnQuXG4gKiBAcGFyYW0gbyBUaGUgb2JqZWN0IHRvIGNvcHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNoYWxsb3dDb3B5PEU+KG86IEUpIHtcbiAgcmV0dXJuIHsgLi4ubyB9O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRlZXAgY29weSBvZiB0aGUgYXJndW1lbnQuXG4gKiBAcGFyYW0gbyBUaGUgb2JqZWN0IHRvIGNvcHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZXBDb3B5PEU+KG86IEUpIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobykpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGN1cnJlbnQgYWN0aXZlIHZhbHVlIGZyb20gdGhlIGBhY3RpdmVgXG4gKiBNYXAuICBcbiAqIFxuICogVGhpcyBpcyB1c2VkIGZvciB0aGUgc2NlbmFyaW8gd2hlcmUgd2UgYXJlIG1hbmFnaW5nXG4gKiBhIHNpbmdsZSBhY3RpdmUgaW5zdGFuY2UuICBGb3IgZXhhbXBsZSBcbiAqIHdoZW4gc2VsZWN0aW5nIGEgYm9vayBmcm9tIGEgY29sbGVjdGlvbiBvZiBib29rcy4gIFxuICogXG4gKiBUaGUgc2VsZWN0ZWQgYEJvb2tgIGluc3RhbmNlIGJlY29tZXMgdGhlIGFjdGl2ZSB2YWx1ZS5cbiAqIFxuICogQGV4YW1wbGVcbiAqIGNvbnN0IGJvb2s6Qm9vayA9IGdldEFjdGl2ZVZhbHVlKGJvb2tTdG9yZS5hY3RpdmUpO1xuICogQHBhcmFtIG0gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBY3RpdmVWYWx1ZTxFPihtOiBNYXA8YW55LCBFPikge1xuICBpZiAobS5zaXplKSB7XG4gICAgcmV0dXJuIG0uZW50cmllcygpLm5leHQoKS52YWx1ZVsxXTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBUaGUgbWV0aG9kIGNhbiBiZSB1c2VkIHRvIGV4Y2x1ZGUga2V5cyBmcm9tIGFuIGluc3RhbmNlXG4gKiBvZiB0eXBlIGBFYC4gIFxuICogXG4gKiBXZSBjYW4gdXNlIHRoaXMgdG8gZXhjbHVkZSB2YWx1ZXMgd2hlbiBzZWFyY2hpbmcgYW4gb2JqZWN0LlxuICogXG4gKiBAcGFyYW0gZW50aXR5IEFuIGluc3RhbmNlIG9mIHR5cGUgRVxuICogQHBhcmFtIGV4Y2x1ZGUgVGhlIGtleXMgdG8gZXhjbHVkZVxuICogXG4gKiBAZXhhbXBsZVxuICogdG9kbyA9IHsgaWQ6ICcxJywgZGVzY3JpcHRpb246ICdEbyBpdCEnIH1cbiAqIGxldCBrZXlzID0gZXhjbHVkZUtleXM8VG9kbz4odG9kbywgWydpZF0pO1xuICogLy8ga2V5cyA9IFsnZGVzY3JpcHRpb24nXVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhjbHVkZUtleXM8RT4oZW50aXR5OiBFLCBleGNsdWRlOiBzdHJpbmdbXSkge1xuICBjb25zdCBrZXlzOiBzdHJpbmdbXSA9IE9iamVjdC5rZXlzKGVudGl0eSk7XG4gIHJldHVybiBrZXlzLmZpbHRlcigoa2V5KSA9PiB7XG4gICAgcmV0dXJuIGV4Y2x1ZGUuaW5kZXhPZihrZXkpIDwgMDtcbiAgfSk7XG59XG5cbi8qKlxuICogXG4gKiBAcGFyYW0gZW50aXRpZXMgVGhlIGVudGl0eSB0byBzZWFyY2hcbiAqIEBwYXJhbSBleGNsdWRlIEtleXMgdG8gZXhjbHVkZSBmcm9tIGVhY2ggZW50aXR5XG4gKiBcbiAqIEByZXR1cm4gRVtdIEFycmF5IG9mIGVudGl0aWVzIHdpdGggcHJvcGVydGllcyBjb250YWluaW5nIHRoZSBzZWFyY2ggdGVybS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlYXJjaDxFPihxdWVyeTogc3RyaW5nID0gJycsIGVudGl0aWVzOiBFW10sIGV4Y2x1ZGU6IHN0cmluZ1tdID0gW10pOiBFW10ge1xuICBjb25zdCB7IGlzQXJyYXkgfSA9IEFycmF5XG5cbiAgcXVlcnkgPSBxdWVyeS50b0xvd2VyQ2FzZSgpO1xuXG5cbiAgcmV0dXJuIGVudGl0aWVzLmZpbHRlcihmdW5jdGlvbiAoZTogRSkge1xuICAgIC8vRG8gdGhlIGtleXMgY2FsY3VsYXRpb24gb24gZWFjaCBpbnN0YW5jZSBlOkVcbiAgICAvL2JlY2F1c2UgYW4gaW5zdGFuY2UgY2FuIGhhdmUgb3B0aW9uYWwgcGFyYW1ldGVycyxcbiAgICAvL2FuZCB0aHVzIHdlIGhhdmUgdG8gY2hlY2sgZWFjaCBpbnN0YW5jZSwgbm90IGp1c3RcbiAgICAvL3RoZSBmaXJzdCBvbmUgaW4gdGhlIGFycmF5LlxuICAgIGNvbnN0IGtleXMgPSBleGNsdWRlS2V5cyhlLCBleGNsdWRlKVxuICAgIHJldHVybiBrZXlzLnNvbWUoIChrZXkpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gKGUgYXMgYW55KVtrZXldO1xuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnNvbWUodiA9PiB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyh2KS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHF1ZXJ5KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhxdWVyeSk7XG4gICAgICB9XG4gICAgfSlcbiAgfSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHNjcm9sbGFibGUgVGhlIGVsZW1lbnQgYmVpbmcgc2Nyb2xsZWRcbiAqIEBwYXJhbSBkZWJvdW5jZU1TIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlYm91bmNlIHNjcm9sbCBldmVudHNcbiAqIEBwYXJhbSBzcCBUaGUgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBzY3JvbGwgcG9zaXRpb24gY29vcmRpbmF0ZXMuXG4gKiBAcmV0dXJuIEEgYm9vbGVhbiB2YWx1ZWQgb2JzZXJ2YWJsZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgc2Nyb2xsaW5nIHVwIG9yIGRvd25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjcm9sbGluZ1VwKFxuICBzY3JvbGxhYmxlOiBhbnksIFxuICBkZWJvdW5jZU1TOiBudW1iZXIsIFxuICBzcDogc2Nyb2xsUG9zaXRpb24pOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcbiAgcmV0dXJuIGZyb21FdmVudChzY3JvbGxhYmxlLCAnc2Nyb2xsJykucGlwZShcbiAgICBkZWJvdW5jZVRpbWUoZGVib3VuY2VNUyksIFxuICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKCksIFxuICAgIG1hcCh2ID0+IHNwKCkpLCBcbiAgICBwYWlyd2lzZSgpLCBcbiAgICBzd2l0Y2hNYXAocCA9PiB7XG4gICAgY29uc3QgeTEgPSBwWzBdWzFdXG4gICAgY29uc3QgeTIgPSBwWzFdWzFdXG4gICAgcmV0dXJuIHkxIC0geTIgPiAwID8gb2YoZmFsc2UpIDogb2YodHJ1ZSlcbiAgfSkpXG59XG5cbi8qKlxuICogRmlsdGVycyB0aGUgZW50aXRpZXMgcHJvcGVydGllcyB0byB0aGUgc2V0IGNvbnRhaW5lZCBpbiB0aGUgXG4gKiBga2V5c2AgYXJyYXkuXG4gKiAgXG4gKiBAcGFyYW0ga2V5cyBUaGUgYXJyYXkgb2Yga2V5cyB0aGF0IHRoZSBlbnRpdHkgYmUgbGltaXRlZCB0b1xuICogQHBhcmFtIGVudGl0eSBUaGUgZW50aXR5IHRvIG1hcFxuICogQHJldHVybiBBbiBlbnRpdHkgaW5zdGFuY2UgdGhhdCBoYXMgb25seSB0aGUga2V5cyBwcm92aWRlZCBpbiB0aGUga2V5cyBhcnJheSBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcEVudGl0eShrZXlzOnN0cmluZ1tdLCBlbnRpdHk6YW55KSB7XG4gIGNvbnN0IHJlc3VsdDphbnkgPSB7fVxuICBrZXlzLmZvckVhY2goaz0+e1xuICAgIHJlc3VsdFtrXSA9IGVudGl0eVtrXVxuICB9KVxuICByZXR1cm4gcmVzdWx0XG59Il19