{"version":3,"file":"fireflysemantics-slice.js","sources":["../../../projects/slice/src/lib/models/StoreConfig.ts","../../../projects/slice/src/lib/models/Entity.ts","../../../projects/slice/src/lib/models/constants.ts","../../../projects/slice/src/lib/AbstractStore.ts","../../../projects/slice/src/lib/utilities.ts","../../../projects/slice/src/lib/Slice.ts","../../../projects/slice/src/lib/EStore.ts","../../../projects/slice/src/lib/OStore.ts","../../../projects/slice/src/public-api.ts","../../../projects/slice/src/fireflysemantics-slice.ts"],"sourcesContent":["/**\n * The configuration interface for the entity store\n * defines the strings for the ID Key and Global ID key.\n */\nexport interface StoreConfig {\n    idKey: string;\n    guidKey: string;\n};\n  ","\n/**\n * Abstract Entity base class with the \n * gid and id properties declared.\n */\nexport abstract class Entity {\n    public gid?:string\n    public id?:string \n}","export const SCROLL_UP_DEBOUNCE_TIME_20 = 20;\nexport const SEARCH_DEBOUNCE_TIME_300 = 300;\n","import { ReplaySubject, Observable } from \"rxjs\"\nimport { map } from \"rxjs/operators\"\nimport { Delta, Predicate } from \"./models\"\nimport { StoreConfig } from \"./models/StoreConfig\"\n\nconst { freeze } = Object\n\nconst ESTORE_DEFAULT_ID_KEY = \"id\"\nconst ESTORE_DEFAULT_GID_KEY = \"gid\"\n\nexport const ESTORE_CONFIG_DEFAULT: StoreConfig = freeze({\n  idKey: ESTORE_DEFAULT_ID_KEY,\n  guidKey: ESTORE_DEFAULT_GID_KEY\n});\n\nexport abstract class AbstractStore<E> {\n\n  /**\n   * The configuration for the store.\n   */\n   public config: StoreConfig;\n\n   constructor(config?: StoreConfig) {\n     this.config = config\n       ? freeze({ ...ESTORE_CONFIG_DEFAULT, ...config })\n       : ESTORE_CONFIG_DEFAULT;\n   }\n \n  /**\n   * Notifies observers of the store query.\n   */\n  protected notifyQuery = new ReplaySubject<string>(1);\n\n  /**\n   * The current query state.\n   */\n  protected _query: string = '';\n\n  /**\n   * Sets the current query state and notifies observers.\n   */\n  set query(query: string) {\n    this._query = query;\n    this.notifyQuery.next(this._query);\n  }\n\n  /**\n   * @return A snapshot of the query state.\n   */\n  get query() {\n    return this._query;\n  }\n\n  /**\n   * Observe the query.\n   * @example\n     <pre>\n    let query$ = source.observeQuery();\n    </pre>\n  */\n  public observeQuery() {\n    return this.notifyQuery.asObservable();\n  }\n\n\n  /**\n   * The current id key for the EStore instance.\n   * @return this.config.idKey;\n   */\n  get ID_KEY(): string {\n    return this.config.idKey\n  }\n  /**\n   * The current guid key for the EStore instance.\n   * @return this.config.guidKey;\n   */\n  get GUID_KEY(): string {\n    return this.config.guidKey\n  }\n\n  /**\n   * Primary index for the stores elements.\n   */\n  public entries: Map<string, E> = new Map()\n\n  /**\n   * The element entries that are keyed by\n   * an id generated on the server.\n   */\n  public idEntries: Map<string, E> = new Map()\n\n  /**\n   * Create notifications that broacast\n   * the entire set of entries.\n   */\n  protected notify = new ReplaySubject<E[]>(1)\n\n  /**\n   * Create notifications that broacast\n   * store or slice delta state changes.\n   */\n  protected notifyDelta = new ReplaySubject<Delta<E>>(1)\n\n  /**\n   * Call all the notifiers at once.\n   *\n   * @param v\n   * @param delta\n   */\n  protected notifyAll(v: E[], delta: Delta<E>) {\n    this.notify.next(v);\n    this.notifyDelta.next(delta);\n  }\n\n  /**\n   * Observe store state changes.\n   * @param sort Optional sorting function yielding a sorted observable.\n   * @example\n```\nlet todos$ = source.observe();\n//or with a sort by title function\nlet todos$ = source.observe((a, b)=>(a.title > b.title ? -1 : 1));\n```\n  */\n  public observe(sort?: (a: any, b: any) => number): Observable<E[]> {\n    if (sort) {\n      return this.notify.pipe(map((e: E[]) => e.sort(sort)));\n    }\n    return this.notify.asObservable();\n  }\n\n  /**\n   * Observe delta updates.\n   * @example\n     <pre>\n     let todos$ = source.observeDelta();\n     </pre>\n   */\n  public observeDelta(): Observable<Delta<E>> {\n    return this.notifyDelta.asObservable();\n  }\n\n  /**\n   * Check whether the store is empty.\n   * \n   * @return A hot {@link Observable} that indicates whether the store is empty.\n   * \n   * @example\n    <pre>\n    source.isEmpty();\n    </pre>\n  */\n  isEmpty(): Observable<boolean> {\n    return this.notify.pipe(\n      map((entries: E[]) => entries.length == 0)\n    );\n  }\n\n  /**\n   * Check whether the store is empty.\n   * \n   * @return A snapshot that indicates whether the store is empty.\n   * \n   * @example\n     <pre>\n    source.isEmpty();\n    </pre>\n  */\n  isEmptySnapshot(): boolean {\n    return Array.from(this.entries.values()).length == 0;\n  }\n\n  /**\n   * Returns the number of entries contained.\n   * @param p The predicate to apply in order to filter the count\n   */\n  count(p?: Predicate<E>): Observable<number> {\n    if (p) {\n      return this.notify.pipe(\n        map((e: E[]) => e.reduce((total, e) => total + (p(e) ? 1 : 0), 0))\n      );\n    }\n    return this.notify.pipe(map((entries: E[]) => entries.length));\n  }\n\n  /**\n   * Returns a snapshot of the number of entries contained in the store.\n   * @param p The predicate to apply in order to filter the count\n   */\n  countSnapshot(p?: Predicate<E>): number {\n    if (p) {\n      return Array.from(this.entries.values()).filter(p).length;\n    }\n    return Array.from(this.entries.values()).length;\n  }\n\n  /**\n   * Snapshot of all entries.\n   * \n   * @return Snapshot array of all the elements the entities the store contains.\n   * \n   * @example Observe a snapshot of all the entities in the store.\n```\nlet selectedTodos:Todo[] = source.allSnapshot();\n```\n   */\n  allSnapshot(): E[] {\n    return Array.from(this.entries.values());\n  }\n\n  /**\n   * Returns true if the entries contain the identified instance.\n   * \n   * @param target Either an instance of type `E` or a `guid` identifying the instance. \n   * @param byId Whether the lookup should be performed with the `id` key rather than the `guid`.\n   * @returns true if the instance identified by the guid exists, false otherwise.\n   * \n   * @example\n     <pre>\n     let contains:boolean = source.contains(guid);\n     </pre>\n   */\n  contains(target: E | string):boolean {\n    if (typeof target === \"string\") {\n      return this.entries.get(target) ? true : false;\n    }\n    const guid: string = (<any>target)[this.config.guidKey];\n    return this.entries.get(guid) ? true : false;\n  }\n\n  /**\n   * Returns true if the entries contain the identified instance.\n   * \n   * @param target Either an instance of type `E` or a `id` identifying the instance. \n   * @returns true if the instance identified by the `id` exists, false otherwise.\n   * \n   * @example\n     <pre>\n     let contains:boolean = source.contains(guid);\n     </pre>\n   */\n  containsById(target: E | string):boolean {\n    if (typeof target === \"string\") {\n      return this.idEntries.get(target) ? true : false;\n    }\n    const id: string = (<any>target)[this.config.idKey];\n    return this.idEntries.get(id) ? true : false;\n  }\n\n  /**\n   * Find and return the entity identified by the GUID parameter\n   * if it exists and return it.\n   *\n   * @param guid\n   * @return The entity instance if it exists, null otherwise\n   */\n  findOne(guid: string): E | undefined{\n    return this.entries.get(guid);\n  }\n\n  /**\n   * Find and return the entity identified by the ID parameter\n   * if it exists and return it.\n   *\n   * @param id\n   * @return The entity instance if it exists, null otherwise\n   */\n  findOneByID(id: string): E | undefined {\n    return this.idEntries.get(id);\n  }\n\n  /**\n   * Snapshot of the entries that match the predicate.\n   *\n   * @param p The predicate used to query for the selection.\n   * @return A snapshot array containing the entities that match the predicate.\n   * \n   * @example Select all the `Todo` instance where the `title` length is greater than 100. \n```\nlet todos:Todo[]=store.select(todo=>todo.title.length>100);\n```\n   */\n  select(p: Predicate<E>): E[] {\n    const selected: E[] = [];\n    Array.from(this.entries.values()).forEach(e => {\n      if (p(e)) {\n        selected.push(e);\n      }\n    });\n    return selected;\n  }\n\n  /** \n   * Compare entities by GUID \n   * @param e1 The first entity\n   * @param e2 The second entity\n   * @return true if the two entities have equal GUID ids\n   * @example Compare `todo1` with `todo2` by `gid`.\n```\nif (equalsByGUID(todo1, todo2)){...};\n```\n   */\n  equalsByGUID(e1:any, e2:any) {\n    return e1[this.GUID_KEY] == e2[this.GUID_KEY];\n  }\n\n  /**\n   * Compare entities by ID \n   * @param e1 The first entity\n   * @param e2 The second entity\n   * @return true if the two entities have equal ID ids\n   * @example Compare `todo1` with `todo2` by `id`.\n```\nif (equalsByID(todo1, todo2)){...};\n```\n   */\n  equalsByID(e1:any, e2:any) {\n    return e1[this.ID_KEY] == e2[this.ID_KEY];\n  }\n  /**\n   * Calls complete on all {@link BehaviorSubject} instances.\n   * \n   * Call destroy when disposing of the store.\n   */\n  destroy() {\n    this.notify.complete();\n    this.notifyDelta.complete();\n    this.notifyQuery.complete();\n  }\n}","import { ESTORE_CONFIG_DEFAULT } from \"./AbstractStore\";\nimport { Observable, fromEvent, of } from 'rxjs'\nimport { switchMap, pairwise, debounceTime, distinctUntilChanged, map } from 'rxjs/operators'\nimport { nanoid} from \"nanoid\"\nimport { scrollPosition } from \"./models/scrollPosition\";\n\n/**\n * Returns all the entities are distinct by the \n * `property` value argument.  \n * \n * Note that the implementation uses a `Map<string, E>` to\n * index the entities by key.  Therefore the more recent occurences \n * matching a key instance will overwrite the previous ones.\n * \n * @param property The name of the property to check for distinct values by.\n * @param entities The entities in the array.\n * \n * @example\n ```\n  let todos: Todo[] = [\n    { id: 1, title: \"Lets do it!\" },\n    { id: 1, title: \"Lets do it again!\" },\n    { id: 2, title: \"All done!\" }\n  ];\n\n  let todos2: Todo[] = [\n    { id: 1, title: \"Lets do it!\" },\n    { id: 2, title: \"All done!\" }\n  ];\n\n  expect(distinct(todos, \"id\").length).toEqual(2);\n  expect(distinct(todos2, \"id\").length).toEqual(2);\n\n ```\n */\nexport function distinct<E, K extends keyof E>(entities: E[], property: K): E[] {\n  const entitiesByProperty = new Map(entities.map(e => [e[property], e] as [E[K], E]));\n  return Array.from(entitiesByProperty.values());\n}\n\n/**\n * Returns true if all the entities are distinct by the \n * `property` value argument.\n * \n * @param property The name of the property to check for distinct values by.\n * @param entities The entities in the array.\n * \n * @example\n * \n ```\n  let todos: Todo[] = [\n    { id: 1, title: \"Lets do it!\" },\n    { id: 1, title: \"Lets do it again!\" },\n    { id: 2, title: \"All done!\" }\n  ];\n\n  let todos2: Todo[] = [\n    { id: 1, title: \"Lets do it!\" },\n    { id: 2, title: \"All done!\" }\n  ];\n\n  expect(unique(todos, \"id\")).toBeFalsy();\n  expect(unique(todos2, \"id\")).toBeTruthy();\n ```\n */\nexport function unique<E>(entities: E[], property: keyof E):boolean {\n  return entities.length == distinct(entities, property).length ? true : false;\n}\n\n/**\n * Create a global ID\n * @return The global id.\n * \n * @example\n * let e.guid = GUID();\n */\nexport function GUID() {\n  return nanoid();\n}\n\n/**\n * Set the global identfication property on the instance.\n * \n * @param e Entity we want to set the global identifier on.\n * @param gid The name of the `gid` property.  If not specified it defaults to `ESTORE_CONFIG_DEFAULT.guidKey`.\n */\nexport function attachGUID<E>(e: E, gid?: string): string {\n  const guidKey = gid ? gid : ESTORE_CONFIG_DEFAULT.guidKey\n  let id: string = nanoid();\n  (<any>e)[guidKey] = id\n  return id\n}\n\n/**\n * Set the global identfication property on the instance.\n * \n * @param e[] Entity array we want to set the global identifiers on.\n * @param gid The name of the `gid` property.  If not specified it defaults to `gid`.\n */\nexport function attachGUIDs<E>(e: E[], gid?: string) {\n  e.forEach(e => {\n    attachGUID(e, gid);\n  });\n}\n\n/**\n * Create a shallow copy of the argument.\n * @param o The object to copy\n */\nexport function shallowCopy<E>(o: E) {\n  return { ...o };\n}\n\n/**\n * Create a deep copy of the argument.\n * @param o The object to copy\n */\nexport function deepCopy<E>(o: E) {\n  return JSON.parse(JSON.stringify(o));\n}\n\n/**\n * Gets the current active value from the `active`\n * Map.  \n * \n * This is used for the scenario where we are managing\n * a single active instance.  For example \n * when selecting a book from a collection of books.  \n * \n * The selected `Book` instance becomes the active value.\n * \n * @example\n * const book:Book = getActiveValue(bookStore.active);\n * @param m \n */\nexport function getActiveValue<E>(m: Map<any, E>) {\n  if (m.size) {\n    return m.entries().next().value[1];\n  }\n  return null;\n}\n\n/**\n * The method can be used to exclude keys from an instance\n * of type `E`.  \n * \n * We can use this to exclude values when searching an object.\n * \n * @param entity An instance of type E\n * @param exclude The keys to exclude\n * \n * @example\n * todo = { id: '1', description: 'Do it!' }\n * let keys = excludeKeys<Todo>(todo, ['id]);\n * // keys = ['description']\n */\nexport function excludeKeys<E>(entity: E, exclude: string[]) {\n  const keys: string[] = Object.keys(entity);\n  return keys.filter((key) => {\n    return exclude.indexOf(key) < 0;\n  });\n}\n\n/**\n * \n * @param entities The entity to search\n * @param exclude Keys to exclude from each entity\n * \n * @return E[] Array of entities with properties containing the search term.\n */\nexport function search<E>(query: string = '', entities: E[], exclude: string[] = []): E[] {\n  const { isArray } = Array\n\n  query = query.toLowerCase();\n\n\n  return entities.filter(function (e: E) {\n    //Do the keys calculation on each instance e:E\n    //because an instance can have optional parameters,\n    //and thus we have to check each instance, not just\n    //the first one in the array.\n    const keys = excludeKeys(e, exclude)\n    return keys.some( (key) => {\n      const value = (e as any)[key];\n      if (!value) {\n        return false;\n      }\n      if (isArray(value)) {\n        return value.some(v => {\n          return String(v).toLowerCase().includes(query);\n        });\n      }\n      else {\n        return String(value).toLowerCase().includes(query);\n      }\n    })\n  });\n}\n\n/**\n * @param scrollable The element being scrolled\n * @param debounceMS The number of milliseconds to debounce scroll events\n * @param sp The function returning the scroll position coordinates.\n * @return A boolean valued observable indicating whether the element is scrolling up or down\n */\nexport function scrollingUp(\n  scrollable: any, \n  debounceMS: number, \n  sp: scrollPosition): Observable<boolean> {\n  return fromEvent(scrollable, 'scroll').pipe(\n    debounceTime(debounceMS), \n    distinctUntilChanged(), \n    map(v => sp()), \n    pairwise(), \n    switchMap(p => {\n    const y1 = p[0][1]\n    const y2 = p[1][1]\n    return y1 - y2 > 0 ? of(false) : of(true)\n  }))\n}\n\n/**\n * Filters the entities properties to the set contained in the \n * `keys` array.\n *  \n * @param keys The array of keys that the entity be limited to\n * @param entity The entity to map\n * @return An entity instance that has only the keys provided in the keys array \n */\nexport function mapEntity(keys:string[], entity:any) {\n  const result:any = {}\n  keys.forEach(k=>{\n    result[k] = entity[k]\n  })\n  return result\n}","import { Delta, ActionTypes, Predicate } from \"./models\"\nimport { AbstractStore } from \"./AbstractStore\"\nimport { EStore } from \"./EStore\";\n\nconst { isArray } = Array\n\nexport class Slice<E> extends AbstractStore<E> {\n\n\n    /* The slice element entries */\n    public entries: Map<string, E> = new Map();\n\n    /**\n     * perform initial notification to all observers,\n     * such that operations like {@link combineLatest}{}\n     * will execute at least once.\n     * \n     * @param label The slice label\n     * @param predicate The slice predicate\n     * @param eStore The EStore instance containing the elements considered for slicing\n     * \n     * @example \n       <pre>\n       //Empty slice\n       new Slice<Todo>(Todo.COMPLETE, todo=>!todo.complete);\n  \n       //Initialized slice\n       let todos = [new Todo(false, \"You complete me!\"), \n                    new Todo(true, \"You completed me!\")];\n       new Slice<Todo>(Todo.COMPLETE, todo=>!todo.complete, todos);\n       </pre>\n     */\n    constructor(\n        public label: string,\n        public predicate: Predicate<E>,\n        public eStore: EStore<E>) {\n        super();\n        const entities: E[] = eStore.allSnapshot()\n        this.config = eStore.config\n        let passed: E[] = this.test(predicate, entities);\n        const delta: Delta<E> = { type: ActionTypes.INTIALIZE, entries: passed };\n        this.post(passed);\n        this.notifyDelta.next(delta)\n    }\n\n    /**\n     * Add the element if it satisfies the predicate\n     * and notify subscribers that an element was added.\n     *\n     * @param e The element to be considered for slicing\n     */\n    post(e: E | E[]) {\n        if (isArray(e)) {\n            this.postA(e)\n        }\n        else {\n            if (this.predicate(e)) {\n                const id = (<any>e)[this.config.guidKey];\n                this.entries.set(id, e);\n                const delta: Delta<E> = { type: ActionTypes.POST, entries: [e] };\n                this.notifyAll([...Array.from(this.entries.values())], delta);\n            }\n        }\n    }\n\n    /**\n     * Add the elements if they satisfy the predicate\n     * and notify subscribers that elements were added.\n     *\n     * @param e The element to be considered for slicing\n     */\n    postN(...e: E[]) {\n        this.postA(e);\n    }\n\n    /**\n     * Add the elements if they satisfy the predicate\n     * and notify subscribers that elements were added.\n     *\n     * @param e The element to be considered for slicing\n     */\n    postA(e: E[]) {\n        const d: E[] = [];\n        e.forEach(e => {\n            if (this.predicate(e)) {\n                const id = (<any>e)[this.config.guidKey];\n                this.entries.set(id, e);\n                d.push(e);\n            }\n        });\n        const delta: Delta<E> = { type: ActionTypes.POST, entries: d };\n        this.notifyAll([...Array.from(this.entries.values())], delta);\n    }\n\n    /**\n     * Delete an element from the slice.\n     *\n     * @param e The element to be deleted if it satisfies the predicate\n     */\n    delete(e: E | E[]) {\n        if (isArray(e)) {\n            this.deleteA(e)\n        }\n        else {\n            if (this.predicate(e)) {\n                const id = (<any>e)[this.config.guidKey]\n                this.entries.delete(id)\n                const delta: Delta<E> = { type: ActionTypes.DELETE, entries: [e] }\n                this.notifyAll(Array.from(this.entries.values()), delta)\n            }\n        }\n    }\n\n    /**\n     * @param e The elements to be deleted if it satisfies the predicate\n     */\n    deleteN(...e: E[]) {\n        this.deleteA(e);\n    }\n\n    /**\n     * @param e The elements to be deleted if they satisfy the predicate\n     */\n    deleteA(e: E[]) {\n        const d: E[] = []\n        e.forEach(e => {\n            if (this.predicate(e)) {\n                const id = (<any>e)[this.config.guidKey]\n                d.push(this.entries.get(id)!)\n                this.entries.delete(id)\n            }\n        });\n        const delta: Delta<E> = { type: ActionTypes.DELETE, entries: d };\n        this.notifyAll([...Array.from(this.entries.values())], delta);\n    }\n\n    /**\n     * Update the slice when an Entity instance mutates.\n     *\n     * @param e The element to be added or deleted depending on predicate reevaluation\n     */\n    put(e: E | E[]) {\n        if (isArray(e)) {\n            this.putA(e)\n        }\n        else {\n            const id = (<any>e)[this.config.guidKey];\n            if (this.entries.get(id)) {\n                if (!this.predicate(e)) {\n                    //Note that this is a ActionTypes.DELETE because we are removing the\n                    //entity from the slice.\n                    const delta: Delta<E> = { type: ActionTypes.DELETE, entries: [e] };\n                    this.entries.delete(id);\n                    this.notifyAll([...Array.from(this.entries.values())], delta);\n                }\n            } else if (this.predicate(e)) {\n                this.entries.set(id, e);\n                const delta: Delta<E> = { type: ActionTypes.PUT, entries: [e] };\n                this.notifyAll([...Array.from(this.entries.values())], delta);\n            }    \n        }\n    }\n\n    /**\n     * Update the slice with mutated Entity instances.\n     *\n     * @param e The elements to be deleted if it satisfies the predicate\n     */\n    putN(...e: E[]) {\n        this.putA(e);\n    }\n\n    /**\n     * @param e The elements to be put\n     */\n    putA(e: E[]) {\n        const d: E[] = []; //instances to delete\n        const u: E[] = []; //instances to update\n        e.forEach(e => {\n            const id = (<any>e)[this.config.guidKey];\n            if (this.entries.get(id)) {\n                if (!this.predicate(e)) {\n                    d.push(this.entries.get(id)!);\n                }\n            } else if (this.predicate(e)) {\n                u.push(e);\n            }\n        });\n        if (d.length > 0) {\n            d.forEach(e => {\n                this.entries.delete((<any>e)[this.config.guidKey])\n            });\n            const delta: Delta<E> = { type: ActionTypes.DELETE, entries: d };\n            this.notifyAll([...Array.from(this.entries.values())], delta);\n        }\n        if (u.length > 0) {\n            u.forEach(e => {\n                this.entries.set((<any>e)[this.config.guidKey], e);\n            });\n            const delta: Delta<E> = { type: ActionTypes.PUT, entries: u };\n            this.notifyAll([...Array.from(this.entries.values())], delta);\n        }\n    }\n\n    /**\n     * Resets the slice to empty.\n     */\n    reset() {\n        let delta: Delta<E> = {\n            type: ActionTypes.RESET,\n            entries: [...Array.from(this.entries.values())]\n        };\n        this.notifyAll([], delta);\n        this.entries = new Map();\n    }\n\n    /**\n     * Utility method that applies the predicate to an array\n     * of entities and return the ones that pass the test.\n     *\n     * Used to create an initial set of values\n     * that should be part of the `Slice`.\n     *\n     * @param p\n     * @param e\n     * @return The the array of entities that pass the predicate test.\n     */\n    public test(p: Predicate<E>, e: E[]): E[] {\n        let v: E[] = [];\n        e.forEach((e: E) => {\n            if (p(e)) {\n                v.push(e);\n            }\n        });\n        return v;\n    }\n}\n","import { AbstractStore } from './AbstractStore';\nimport { StoreConfig } from './models/StoreConfig';\nimport { GUID } from './utilities';\n\nimport { ActionTypes, Predicate, Delta } from './models/';\nimport { ReplaySubject, of, Observable } from 'rxjs';\nimport { takeWhile, filter, switchMap } from 'rxjs/operators';\nimport { Slice } from './Slice';\n\n/**\n * This `todoFactory` code will be used to illustrate the API examples.  The following\n * utilities are used in the tests and the API Typedoc examples contained here.\n * @example Utilities for API Examples\n```\nexport const enum TodoSliceEnum {\n  COMPLETE = \"Complete\",\n  INCOMPLETE = \"Incomplete\"\n}\n\nexport class Todo {\n  constructor(public complete: boolean, public title: string,public gid?:string, public id?:string) {}\n}\n\nexport let todos = [new Todo(false, \"You complete me!\"), new Todo(true, \"You completed me!\")];\n\nexport function todosFactory():Todo[] {\n  return [new Todo(false, \"You complete me!\"), new Todo(true, \"You completed me!\")];\n}\n ``` \n */\n\nexport class EStore<E> extends AbstractStore<E> {\n  /**\n   * Store constructor (Initialization with element is optional)\n   *\n   * perform initial notification to all observers,\n   * such that function like {@link combineLatest}{}\n   * will execute at least once.\n   * @param entities\n   * @example Dynamic `EStore<Todo>` Creation \n```\n// Initialize the Store\nlet store: EStore<Todo> = new EStore<Todo>(todosFactory());\n```*/\n  constructor(entities: E[] = [], config?: StoreConfig) {\n    super(config);\n    const delta: Delta<E> = { type: ActionTypes.INTIALIZE, entries: entities };\n    this.post(entities)\n    this.notifyDelta.next(delta);\n  }\n\n  /**\n   * Calls complete on all {@link BehaviorSubject} instances.\n   * \n   * Call destroy when disposing of the store.\n   */\n  destroy() {\n    super.destroy()\n    this.notifyLoading.complete()\n    this.notifyActive.complete()\n    this.slices.forEach(slice => slice.destroy())\n  }\n\n  /**\n   * Toggles the entity:\n   * \n   * If the store contains the entity\n   * it will be deleted.  If the store \n   * does not contains the entity,\n   * it is added.\n   * @param e \n   * @example Toggle the `Todo` instance\n```\nestore.post(todo);\n// Remove todo\nestore.toggle(todo);\n// Add it back\nestore.toggle(todo);\n\n```\n   */\n  public toggle(e: E) {\n    if (this.contains(e)) {\n      this.delete(e);\n    } else {\n      this.post(e);\n    }\n  }\n\n  /**\n   * An Observable<E[]> reference so that \n   * \n   */\n  public observable: Observable<E[]> = this.observe()\n\n  /**\n   * Notifies observers when the store is empty.\n   */\n  private notifyActive = new ReplaySubject<Map<string, E>>(1);\n\n\n  /**\n   * `Map` of active entties. The instance is public and can be used\n   * directly to add and remove active entities, however we recommend\n   * using the {@link addActive} and {@link deleteActive} methods.\n   */\n  public active: Map<string, E> = new Map();\n\n  /**\n   * Add multiple entity entities to active.\n   * \n   * If the entity is not contained in the store it is added\n   * to the store before it is added to `active`.\n   * \n   * Also we clone the map prior to broadcasting it with\n   * `notifyActive` to make sure we will trigger Angular \n   * change detection in the event that it maintains \n   * a reference to the `active` state `Map` instance.\n   * \n   * @example Add a `todo1` and `todo2` as active\n```\naddActive(todo1);\naddActive(todo2);\n```\n   */\n  public addActive(e: E) {\n    if (this.contains(e)) {\n      this.active.set((<any>e).gid, e);\n      this.notifyActive.next(new Map(this.active));\n    }\n    else {\n      this.post(e);\n      this.active.set((<any>e).gid, e);\n      this.notifyActive.next(new Map(this.active));\n    }\n  }\n\n  /**\n   * Delete an entity as active.\n   * \n   * Also we clone the map prior to broadcasting it with\n   * `notifyActive` to make sure we will trigger Angular \n   * change detection in the event that it maintains \n   * a reference to the `active` state `Map` instance.\n   * \n   * @example Mark a `todo` instance as active\n  ```\ndeleteActive(todo1);\ndeleteActive(todo2);\n  ```\n   */\n  public deleteActive(e: E) {\n    this.active.delete((<any>e).gid);\n    this.notifyActive.next(new Map(this.active));\n  }\n\n  /**\n   * Clear / reset the active entity map.\n   * \n   * Also we clone the map prior to broadcasting it with\n   * `notifyActive` to make sure we will trigger Angular \n   * change detection in the event that it maintains \n   * a reference to the `active` state `Map` instance.\n   * \n   * @example Mark a `todo` instance as active\n  ```\ndeleteActive(todo1);\ndeleteActive(todo2);\n  ```\n   */\n  clearActive() {\n    this.active.clear();\n    this.notifyActive.next(new Map(this.active));\n  }\n\n  /**\n   * Observe the active entity.\n   * @example\n     <pre>\n    let active$ = source.observeActive();\n    </pre>\n  */\n  public observeActive() {\n    return this.notifyActive.asObservable()\n  }\n\n\n  //================================================\n  // LOADING\n  //================================================\n\n  /**\n   * Observable of errors occurred during a load request.\n   * \n   * The error Observable should be created by the \n   * client.\n   */\n  public loadingError!: Observable<any>;\n\n  /**\n   * Notifies observers when the store is loading.\n   * \n   * This is a common pattern found when implementing\n   * `Observable` data sources.\n   */\n  private notifyLoading = new ReplaySubject<boolean>(1);\n\n  /**\n   * The current loading state.  Use loading when fetching new\n   * data for the store.  The default loading state is `true`.\n   * \n   * This is such that if data is fetched asynchronously \n   * in a service, components can wait on loading notification\n   * before attempting to retrieve data from the service.\n   *\n   * Loading could be based on a composite response.  For example\n   * when the stock and mutual funds have loaded, set loading to `false`.\n   */\n  private _loading: boolean = true;\n\n  /**\n   * Sets the current loading state and notifies observers.\n   */\n  set loading(loading: boolean) {\n    this._loading = loading;\n    this.notifyLoading.next(this._loading);\n  }\n\n  /**\n   * @return A snapshot of the loading state.\n   */\n  get loading() {\n    return this._loading;\n  }\n\n  /**\n   * Observe loading.\n   * @example\n     <pre>\n    let loading$ = source.observeLoading();\n    </pre>\n\n    Note that this obverable piped through\n    `takeWhile(v->v, true), such that it will \n    complete after each emission.\n\n    See:\n    https://medium.com/@ole.ersoy/waiting-on-estore-to-load-8dcbe161613c\n\n    For more details.\n  */\n  public observeLoading() {\n    return this.notifyLoading.asObservable().\n      pipe(takeWhile(v => v, true));\n  }\n\n  /**\n   * Notfiies when loading has completed.\n   */\n  public observeLoadingComplete() {\n    return this.observeLoading().pipe(\n      filter(loading => loading == false),\n      switchMap(() => of(true)))\n  }\n\n\n\n\n\n\n  //================================================\n  // SEARCHING\n  //================================================\n  /**\n   * Observable of errors occurred during a search request.\n   * \n   * The error Observable should be created by the \n   * client.\n   */\n  public searchError!: Observable<any>;\n\n  /**\n   * Notifies observers that a search is in progress.\n   * \n   * This is a common pattern found when implementing\n   * `Observable` data sources.\n   */\n  private notifySearching = new ReplaySubject<boolean>(1);\n\n  /**\n   * The current `searching` state.  Use `searching`\n   * for example to display a spinnner \n   * when performing a search.  \n   * The default `searching` state is `false`.\n   */\n  private _searching: boolean = false;\n\n  /**\n   * Sets the current searching state and notifies observers.\n   */\n  set searching(searching: boolean) {\n    this._searching = searching;\n    this.notifySearching.next(this._searching);\n  }\n\n  /**\n   * @return A snapshot of the searching state.\n   */\n  get searching() {\n    return this._searching;\n  }\n\n  /**\n   * Observe searching.\n   * @example\n     <pre>\n    let searching$ = source.observeSearching();\n    </pre>\n  \n    Note that this obverable piped through\n    `takeWhile(v->v, true), such that it will \n    complete after each emission.\n  \n    See:\n    https://medium.com/@ole.ersoy/waiting-on-estore-to-load-8dcbe161613c\n  \n    For more details.\n  */\n  public observeSearching(): Observable<boolean> {\n    return this.notifySearching.asObservable().\n      pipe(takeWhile(v => v, true));\n  }\n\n  /**\n   * Notfiies when searching has completed.\n   */\n  public observeSearchingComplete(): Observable<boolean> {\n    return this.observeSearching().pipe(\n      filter(searching => searching == false),\n      switchMap(() => of(true)))\n  }\n\n\n\n\n\n\n\n  /**\n   * Store slices\n   */\n  private slices: Map<string, Slice<E>> = new Map();\n\n  /**\n   * Adds a slice to the store and keys it by the slices label.\n   *\n   * @param p\n   * @param label\n   * \n   * @example Setup a Todo Slice for COMPLETE Todos\n```\nsource.addSlice(todo => todo.complete, TodoSlices.COMPLETE);\n```\n   */\n  addSlice(p: Predicate<E>, label: string) {\n    const slice: Slice<E> = new Slice(\n      label,\n      p,\n      this)\n    this.slices.set(slice.label, slice)\n  }\n\n  /**\n   * Remove a slice\n   * @param label The label identifying the slice\n   * \n   * @example Remove the TodoSlices.COMPLETE Slice\n```\nsource.removeSlice(TodoSlices.COMPLETE);\n```\n   */\n  removeSlice(label: string) {\n    this.slices.delete(label);\n  }\n\n  /**\n   * Get a slice\n   * @param label The label identifying the slice\n   * @return The Slice instance or undefined \n   * \n   * @example Get the TodoSlices.COMPLETE slice\n```\nsource.getSlice(TodoSlices.COMPLETE);\n```\n   */\n  getSlice(label: string): Slice<E> | undefined {\n    return this.slices.get(label);\n  }\n\n  /**\n   * Post (Add a new) element(s) to the store.\n   * @param e An indiidual entity or an array of entities\n   * @example Post a `todo`.\n```\nstore.post(todo);\n```\n   */\n  post(e: E | E[]) {\n    if (!Array.isArray(e)) {\n      const guid: string = (<any>e)[this.GUID_KEY]\n        ? (<any>e)[this.GUID_KEY]\n        : GUID();\n      (<any>e)[this.GUID_KEY] = guid;\n      this.entries.set(guid, e);\n      this.updateIDEntry(e);\n      Array.from(this.slices.values()).forEach(s => {\n        s.post(e);\n      });\n      //Create a new array reference to trigger Angular change detection.\n      let v: E[] = [...Array.from(this.entries.values())];\n      const delta: Delta<E> = { type: ActionTypes.POST, entries: [e] };\n      this.notifyAll(v, delta);\n    }\n    else {\n      this.postA(e)\n    }\n  }\n\n  /**\n   * Post elements to the store.\n   * @param ...e\n   * @example Post two `Todo` instances.\n```\nstore.post(todo1, todo2);\n```\n   */\n  postN(...e: E[]) {\n    e.forEach(e => {\n      const guid: string = (<any>e)[this.GUID_KEY]\n        ? (<any>e)[this.GUID_KEY]\n        : GUID();\n      (<any>e)[this.GUID_KEY] = guid;\n      this.entries.set(guid, e);\n      this.updateIDEntry(e);\n    });\n    Array.from(this.slices.values()).forEach(s => {\n      s.postA(e);\n    });\n    //Create a new array reference to trigger Angular change detection.\n    let v: E[] = [...Array.from(this.entries.values())];\n    const delta: Delta<E> = { type: ActionTypes.POST, entries: e };\n    this.notifyAll(v, delta);\n  }\n\n  /**\n   * Post (Add) an array of elements to the store.\n   * @param e\n   * @example Post a `Todo` array.\n```\nstore.post([todo1, todo2]);\n```\n   */\n  postA(e: E[]) {\n    this.postN(...e);\n  }\n\n  /**\n   * Put (Update) an element.\n   * @param e\n   * @example Put a Todo instance.\n```\nstore.put(todo1);\n```\n   */\n  put(e: E | E[]) {\n    if (!Array.isArray(e)) {\n      let id: string = (<any>e)[this.GUID_KEY];\n      this.entries.set(id, e);\n      this.updateIDEntry(e);\n      let v: E[] = [...Array.from(this.entries.values())];\n      this.notify.next(v);\n      const delta: Delta<E> = { type: ActionTypes.PUT, entries: [e] };\n      this.notifyDelta.next(delta);\n      Array.from(this.slices.values()).forEach(s => {\n        s.put(e);\n      });\n    }\n    else {\n      this.putA(e)\n    }\n  }\n\n  /**\n   * Put (Update) an element or add an element that was read from a persistence source\n   * and thus already has an assigned global id`.\n   * @param e\n   * @example Put Todo instances.\n```\nstore.put(todo1, todo2);\n```\n   */\n  putN(...e: E[]) {\n    this.putA(e);\n  }\n\n  /**\n   * Put (Update) the array of elements.\n   * @param e\n   * @example Put Todo instances.\n```\nstore.put([todo1, todo2]);\n```\n   */\n  putA(e: E[]) {\n    e.forEach(e => {\n      let guid: string = (<any>e)[this.GUID_KEY]\n      this.entries.set(guid, e)\n      this.updateIDEntry(e);\n    });\n    //Create a new array reference to trigger Angular change detection.\n    let v: E[] = [...Array.from(this.entries.values())];\n    this.notify.next(v);\n    const delta: Delta<E> = { type: ActionTypes.PUT, entries: e };\n    this.notifyDelta.next(delta);\n    Array.from(this.slices.values()).forEach(s => {\n      s.putA(e);\n    });\n  }\n\n  /**\n   * Delete (Update) the array of elements.\n   * @param e\n   * @example Delete todo1.\n```\nstore.delete(todo1]);\n```\n   */\n  delete(e: E | E[]) {\n    if (!Array.isArray(e)) {\n      this.deleteActive(e);\n      const guid = (<any>e)[this.GUID_KEY];\n      this.entries.delete(guid);\n      this.deleteIDEntry(e);\n      Array.from(this.slices.values()).forEach(s => {\n        s.entries.delete(guid);\n      });\n      //Create a new array reference to trigger Angular change detection.\n      let v: E[] = [...Array.from(this.entries.values())];\n      const delta: Delta<E> = { type: ActionTypes.DELETE, entries: [e] };\n      this.notifyAll(v, delta);\n      Array.from(this.slices.values()).forEach(s => {\n        s.delete(e);\n      });\n    }\n    else {\n      this.deleteA(e)\n    }\n\n  }\n\n  /**\n   * Delete N elements.\n   * @param ...e\n   * @example Put Todo instances.\n```\nstore.delete(todo1, todo2);\n```\n   */\n  deleteN(...e: E[]) {\n    this.deleteA(e);\n  }\n\n  /**\n   * Delete N elements.\n   * @param ...e\n   * @example Put Todo instances.\n```\nstore.delete(todo1, todo2);\n```\n   */\n  deleteA(e: E[]) {\n    e.forEach(e => {\n      this.deleteActive(e);\n      const guid = (<any>e)[this.GUID_KEY];\n      this.entries.delete(guid);\n      this.deleteIDEntry(e);\n      Array.from(this.slices.values()).forEach(s => {\n        s.entries.delete(guid);\n      });\n    });\n    //Create a new array reference to trigger Angular change detection.\n    let v: E[] = [...Array.from(this.entries.values())];\n    const delta: Delta<E> = { type: ActionTypes.DELETE, entries: e };\n    this.notifyAll(v, delta);\n    Array.from(this.slices.values()).forEach(s => {\n      s.deleteA(e);\n    });\n  }\n\n  /**\n   * Delete elements by {@link Predicate}.\n   * @param p The predicate.\n   * @example Put Todo instances.\n```\nstore.delete(todo1, todo2);\n```\n   */\n  deleteP(p: Predicate<E>) {\n    const d: E[] = [];\n    Array.from(this.entries.values()).forEach(e => {\n      if (p(e)) {\n        d.push(e);\n        const id = (<any>e)[this.GUID_KEY];\n        this.entries.delete(id);\n        this.deleteActive(e);\n        this.deleteIDEntry(e);\n      }\n    });\n    //Create a new array reference to trigger Angular change detection.\n    let v: E[] = [...Array.from(this.entries.values())];\n    const delta: Delta<E> = { type: ActionTypes.DELETE, entries: d };\n    this.notifyAll(v, delta);\n    Array.from(this.slices.values()).forEach(s => {\n      s.deleteA(d);\n    });\n  }\n\n  /**\n   * If the entity has the `id` key initialized with a value,\n   * then also add the entity to the `idEntries`.\n   *\n   * @param e The element to be added to the `idEntries`.\n   */\n  private updateIDEntry(e: E) {\n    if ((<any>e)[this.ID_KEY]) {\n      this.idEntries.set((<any>e)[this.ID_KEY], e);\n    }\n  }\n\n  /**\n   * If the entity has the `id` key initialized with a value,\n   * then also delete the entity to the `idEntries`.\n   *\n   * @param e The element to be added to the `idEntries`.\n   */\n  private deleteIDEntry(e: E) {\n    if ((<any>e)[this.ID_KEY]) {\n      this.idEntries.delete((<any>e)[this.ID_KEY]);\n    }\n  }\n\n  /**\n   * Resets the store and all contained slice instances to empty.\n   * Also perform delta notification that sends all current store entries.\n   * The ActionType.RESET code is sent with the delta notification.  Slices\n   * send their own delta notification.\n   * \n   * @example Reset the store.\n```\nstore.reset();\n```\n   */\n  reset() {\n    const delta: Delta<E> = {\n      type: ActionTypes.RESET,\n      entries: Array.from(this.entries.values())\n    };\n    this.notifyAll([], delta);\n    this.entries = new Map();\n    Array.from(this.slices.values()).forEach(s => {\n      s.reset();\n    });\n  }\n\n  /**\n   * Call all the notifiers at once.\n   *\n   * @param v\n   * @param delta\n   */\n  protected notifyAll(v: E[], delta: Delta<E>) {\n    super.notifyAll(v, delta);\n    this.notifyLoading.next(this.loading);\n  }\n}","import { ReplaySubject, Observable } from 'rxjs'\n\n/**\n * Initialize hte store with this.\n */\nexport interface ValueReset {\n    value: any\n    reset?: any\n}\n\n/**\n * OStore Key Value Reset\n */\nexport interface ObsValueReset {\n    value: any\n    reset?: any\n    obs: Observable<any>\n}\n\nexport interface KeyObsValueReset {\n    [key: string]: ObsValueReset\n}\n\nexport interface OStoreStart {\n    [key: string]: ValueReset\n}\n\nexport class OStore<E extends KeyObsValueReset> {\n    /**\n     * Start keys and values\n     * passed in via constructor.\n     */\n    public S!: E\n\n    constructor(start: OStoreStart) {\n        if (start) {\n            this.S = <any>start;\n            const keys = Object.keys(start)\n            keys.forEach((k) => {\n                const ovr = start[k] as ObsValueReset\n                this.post(ovr, ovr.value)\n                ovr.obs = this.observe(ovr)\n            })\n        }\n    }\n\n    /**\n     * Reset the state of the OStore to the\n     * values or reset provided in the constructor\n     * {@link OStoreStart} instance.\n     */\n    public reset() {\n        if (this.S) {\n            const keys = Object.keys(this.S)\n            keys.forEach((k) => {\n                const ovr: ObsValueReset = this.S[k]\n                this.put(ovr, ovr.reset ? ovr.reset : ovr.value)\n            })\n        }\n    }\n\n    /**\n     * Clear all entries\n     */\n    public clear() {\n        this.entries.clear()\n    }\n\n\n    /**\n     * Map of Key Value pair entries\n     * containing values store in this store.\n     */\n    public entries: Map<any, any> = new Map()\n\n    /**\n     * Map of replay subject id to `ReplaySubject` instance.\n     */\n    private subjects: Map<any, ReplaySubject<any>> = new Map()\n\n    /**\n     * Set create a key value pair entry and creates a \n     * corresponding replay subject instance that will\n     * be used to broadcast updates.\n     * \n     * @param key The key identifying the value\n     * @param value The value\n     */\n    public post(key: any, value: any) {\n        this.entries.set(key, value)\n        this.subjects.set(key, new ReplaySubject(1))\n        //Emit immediately so that Observers can receive \n        //the value straight away.\n        const subject = this.subjects.get(key)\n        if (subject) {\n            subject.next(value)\n        }\n    }\n    /**\n     * Update a value and notify subscribers.\n     * \n     * @param key \n     * @param value \n     */\n    public put(key: any, value: any) {\n        this.entries.set(key, value)\n        const subject = this.subjects.get(key)\n        if (subject) {\n            subject.next(value)\n        }\n    }\n\n    /**\n     * Deletes both the value entry and the corresponding {@link ReplaySubject}.\n     * Will unsubscribe the {@link ReplaySubject} prior to deleting it,\n     * severing communication with corresponding {@link Observable}s.\n     *  \n     * @param key \n     */\n    public delete(key: any) {\n        this.entries.delete(key)\n        this.subjects.delete(key)\n        const subject = this.subjects.get(key)\n        if (subject) {\n            subject.unsubscribe()\n        }\n    }\n\n    /**\n     * Observe changes to the values.\n     * \n     * @param key \n     * @return An {@link Observable} of the value\n     */\n    public observe(key: any) {\n        return this.subjects.get(key)!.asObservable()\n    }\n\n    /**\n      * Check whether a value exists.\n      * \n      * @param key \n      * @return True if the entry exists ( Is not null or undefined ) and false otherwise.\n      */\n    public exists(key: any): boolean {\n        return this.entries.get(key) != null\n    }\n\n    /**\n     * Retrieve a snapshot of the \n     * value.\n     *  \n     * @param key \n     * @return A snapshot of the value corresponding to the key.\n     */\n    public snapshot(key: any): any {\n        return this.entries.get(key)\n    }\n\n    /**\n     * Indicates whether the store is empty.\n     * @return true if the store is empty, false otherwise.\n     */\n    public isEmpty() {\n        return Array.from(this.entries.values()).length == 0\n    }\n\n    /**\n     * Returns the number of key value pairs contained.\n     * \n     * @return the number of entries in the store.\n     */\n    public count() {\n        return Array.from(this.entries.values()).length\n    }\n}","/*\n * Public API Surface of slice\n */\nexport * from './lib/models/'\nexport * from './lib/AbstractStore'\nexport * from './lib/EStore'\nexport * from './lib/OStore'\nexport * from './lib/Slice'\nexport * from './lib/utilities'\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],"names":[],"mappings":"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"}