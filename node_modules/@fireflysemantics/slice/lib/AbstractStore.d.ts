import { ReplaySubject, Observable } from "rxjs";
import { Delta, Predicate } from "./models";
import { StoreConfig } from "./models/StoreConfig";
export declare const ESTORE_CONFIG_DEFAULT: StoreConfig;
export declare abstract class AbstractStore<E> {
    /**
     * The configuration for the store.
     */
    config: StoreConfig;
    constructor(config?: StoreConfig);
    /**
     * Notifies observers of the store query.
     */
    protected notifyQuery: ReplaySubject<string>;
    /**
     * The current query state.
     */
    protected _query: string;
    /**
     * Sets the current query state and notifies observers.
     */
    set query(query: string);
    /**
     * @return A snapshot of the query state.
     */
    get query(): string;
    /**
     * Observe the query.
     * @example
       <pre>
      let query$ = source.observeQuery();
      </pre>
    */
    observeQuery(): Observable<string>;
    /**
     * The current id key for the EStore instance.
     * @return this.config.idKey;
     */
    get ID_KEY(): string;
    /**
     * The current guid key for the EStore instance.
     * @return this.config.guidKey;
     */
    get GUID_KEY(): string;
    /**
     * Primary index for the stores elements.
     */
    entries: Map<string, E>;
    /**
     * The element entries that are keyed by
     * an id generated on the server.
     */
    idEntries: Map<string, E>;
    /**
     * Create notifications that broacast
     * the entire set of entries.
     */
    protected notify: ReplaySubject<E[]>;
    /**
     * Create notifications that broacast
     * store or slice delta state changes.
     */
    protected notifyDelta: ReplaySubject<Delta<E>>;
    /**
     * Call all the notifiers at once.
     *
     * @param v
     * @param delta
     */
    protected notifyAll(v: E[], delta: Delta<E>): void;
    /**
     * Observe store state changes.
     * @param sort Optional sorting function yielding a sorted observable.
     * @example
  ```
  let todos$ = source.observe();
  //or with a sort by title function
  let todos$ = source.observe((a, b)=>(a.title > b.title ? -1 : 1));
  ```
    */
    observe(sort?: (a: any, b: any) => number): Observable<E[]>;
    /**
     * Observe delta updates.
     * @example
       <pre>
       let todos$ = source.observeDelta();
       </pre>
     */
    observeDelta(): Observable<Delta<E>>;
    /**
     * Check whether the store is empty.
     *
     * @return A hot {@link Observable} that indicates whether the store is empty.
     *
     * @example
      <pre>
      source.isEmpty();
      </pre>
    */
    isEmpty(): Observable<boolean>;
    /**
     * Check whether the store is empty.
     *
     * @return A snapshot that indicates whether the store is empty.
     *
     * @example
       <pre>
      source.isEmpty();
      </pre>
    */
    isEmptySnapshot(): boolean;
    /**
     * Returns the number of entries contained.
     * @param p The predicate to apply in order to filter the count
     */
    count(p?: Predicate<E>): Observable<number>;
    /**
     * Returns a snapshot of the number of entries contained in the store.
     * @param p The predicate to apply in order to filter the count
     */
    countSnapshot(p?: Predicate<E>): number;
    /**
     * Snapshot of all entries.
     *
     * @return Snapshot array of all the elements the entities the store contains.
     *
     * @example Observe a snapshot of all the entities in the store.
  ```
  let selectedTodos:Todo[] = source.allSnapshot();
  ```
     */
    allSnapshot(): E[];
    /**
     * Returns true if the entries contain the identified instance.
     *
     * @param target Either an instance of type `E` or a `guid` identifying the instance.
     * @param byId Whether the lookup should be performed with the `id` key rather than the `guid`.
     * @returns true if the instance identified by the guid exists, false otherwise.
     *
     * @example
       <pre>
       let contains:boolean = source.contains(guid);
       </pre>
     */
    contains(target: E | string): boolean;
    /**
     * Returns true if the entries contain the identified instance.
     *
     * @param target Either an instance of type `E` or a `id` identifying the instance.
     * @returns true if the instance identified by the `id` exists, false otherwise.
     *
     * @example
       <pre>
       let contains:boolean = source.contains(guid);
       </pre>
     */
    containsById(target: E | string): boolean;
    /**
     * Find and return the entity identified by the GUID parameter
     * if it exists and return it.
     *
     * @param guid
     * @return The entity instance if it exists, null otherwise
     */
    findOne(guid: string): E | undefined;
    /**
     * Find and return the entity identified by the ID parameter
     * if it exists and return it.
     *
     * @param id
     * @return The entity instance if it exists, null otherwise
     */
    findOneByID(id: string): E | undefined;
    /**
     * Snapshot of the entries that match the predicate.
     *
     * @param p The predicate used to query for the selection.
     * @return A snapshot array containing the entities that match the predicate.
     *
     * @example Select all the `Todo` instance where the `title` length is greater than 100.
  ```
  let todos:Todo[]=store.select(todo=>todo.title.length>100);
  ```
     */
    select(p: Predicate<E>): E[];
    /**
     * Compare entities by GUID
     * @param e1 The first entity
     * @param e2 The second entity
     * @return true if the two entities have equal GUID ids
     * @example Compare `todo1` with `todo2` by `gid`.
  ```
  if (equalsByGUID(todo1, todo2)){...};
  ```
     */
    equalsByGUID(e1: any, e2: any): boolean;
    /**
     * Compare entities by ID
     * @param e1 The first entity
     * @param e2 The second entity
     * @return true if the two entities have equal ID ids
     * @example Compare `todo1` with `todo2` by `id`.
  ```
  if (equalsByID(todo1, todo2)){...};
  ```
     */
    equalsByID(e1: any, e2: any): boolean;
    /**
     * Calls complete on all {@link BehaviorSubject} instances.
     *
     * Call destroy when disposing of the store.
     */
    destroy(): void;
}
